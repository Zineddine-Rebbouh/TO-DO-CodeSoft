{
  "version": 3,
  "sources": ["../../classnames/index.js", "../../@react-md/divider/src/Divider.tsx", "../../@react-md/utils/src/applyRef.ts", "../../@react-md/utils/src/bem.ts", "../../@react-md/utils/src/Dir.tsx", "../../@react-md/utils/src/events/useScrollListener.ts", "../../@react-md/utils/src/useRefCache.ts", "../../@react-md/utils/src/hover/constants.ts", "../../@react-md/utils/src/hover/HoverModeProvider.tsx", "../../@react-md/utils/src/useOnUnmount.ts", "../../@react-md/utils/src/hover/useHoverModeContext.ts", "../../@react-md/utils/src/hover/useHoverMode.ts", "../../@react-md/utils/src/mode/UserInteractionModeListener.tsx", "../../@react-md/utils/src/mode/useInteractionMode.ts", "../../@react-md/utils/src/useIsomorphicLayoutEffect.ts", "../../@react-md/utils/src/keyboardMovement/activeDescendantContext.ts", "../../@react-md/utils/src/keyboardMovement/ActiveDescendantMovementProvider.tsx", "../../@react-md/utils/src/keyboardMovement/KeyboardMovementProvider.tsx", "../../@react-md/utils/src/keyboardMovement/movementContext.ts", "../../@react-md/utils/src/loop.ts", "../../@react-md/utils/src/keyboardMovement/useKeyboardFocusableElement.ts", "../../@react-md/utils/src/keyboardMovement/useActiveDescendantFocus.ts", "../../@react-md/utils/src/keyboardMovement/useKeyboardFocus.ts", "../../@react-md/utils/src/layout/Grid.tsx", "../../@react-md/utils/src/sizing/useAppSize.ts", "../../@react-md/utils/src/sizing/useAppSizeMedia.ts", "../../@react-md/utils/src/sizing/constants.ts", "../../@react-md/utils/src/sizing/useOrientation.ts", "../../@react-md/utils/src/sizing/useWidthMediaQuery.ts", "../../@react-md/utils/src/sizing/useMediaQuery.ts", "../../@react-md/utils/src/layout/GridCell.tsx", "../../@react-md/utils/src/layout/GridList.tsx", "../../@react-md/utils/src/layout/GridListCell.tsx", "../../@react-md/utils/src/layout/useGridList.ts", "../../@juggle/resize-observer/lib/utils/resizeObservers.js", "../../@juggle/resize-observer/lib/algorithms/hasActiveObservations.js", "../../@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js", "../../@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js", "../../@juggle/resize-observer/lib/ResizeObserverBoxOptions.js", "../../@juggle/resize-observer/lib/utils/freeze.js", "../../@juggle/resize-observer/lib/ResizeObserverSize.js", "../../@juggle/resize-observer/lib/DOMRectReadOnly.js", "../../@juggle/resize-observer/lib/utils/element.js", "../../@juggle/resize-observer/lib/utils/global.js", "../../@juggle/resize-observer/lib/algorithms/calculateBoxSize.js", "../../@juggle/resize-observer/lib/ResizeObserverEntry.js", "../../@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js", "../../@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js", "../../@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js", "../../@juggle/resize-observer/lib/utils/process.js", "../../@juggle/resize-observer/lib/utils/queueMicroTask.js", "../../@juggle/resize-observer/lib/utils/queueResizeObserver.js", "../../@juggle/resize-observer/lib/utils/scheduler.js", "../../@juggle/resize-observer/lib/ResizeObservation.js", "../../@juggle/resize-observer/lib/ResizeObserverDetail.js", "../../@juggle/resize-observer/lib/ResizeObserverController.js", "../../@juggle/resize-observer/lib/ResizeObserver.js", "../../@react-md/utils/src/useEnsuredRef.ts", "../../@react-md/utils/src/sizing/useResizeObserver.ts", "../../@react-md/utils/src/layout/scrollbarSize.ts", "../../@react-md/utils/src/positioning/findSizingContainer.ts", "../../@react-md/utils/src/scrollIntoView.ts", "../../@react-md/utils/src/search/useKeyboardSearch.ts", "../../@react-md/utils/src/useTempValue.ts", "../../@react-md/utils/src/sizing/AppSizeListener.tsx", "../../@react-md/utils/src/sizing/useResizeListener.ts", "../../@react-md/utils/src/useCloseOnOutsideClick.ts", "../../@react-md/utils/src/useDropzone.ts", "../../@react-md/utils/src/useInterval.ts", "../../@react-md/utils/src/useToggle.ts", "../../@react-md/utils/src/useTimeout.ts", "../../@react-md/utils/src/wia-aria/constants.ts", "../../@react-md/utils/src/wia-aria/FocusContainer.tsx", "../../@react-md/utils/src/wia-aria/useFocusOnMount.ts", "../../@react-md/utils/src/wia-aria/getFocusableElements.ts", "../../@react-md/utils/src/wia-aria/isFocusable.ts", "../../@react-md/utils/src/wia-aria/focusElementWithin.ts", "../../@react-md/utils/src/wia-aria/getInstance.ts", "../../@react-md/utils/src/wia-aria/usePreviousFocus.ts", "../../@react-md/utils/src/wia-aria/useTabFocusWrap.ts", "../../@react-md/utils/src/wia-aria/movement/types.ts", "../../@react-md/utils/src/wia-aria/movement/presets.ts", "../../@react-md/utils/src/wia-aria/movement/useKeyboardMovement.ts", "../../@react-md/utils/src/wia-aria/movement/useActiveDescendantMovement.ts", "../../@react-md/utils/src/wia-aria/movement/useFocusMovement.ts", "../../@react-md/utils/src/wia-aria/radio/RadioGroup.tsx", "../../@react-md/utils/src/wia-aria/tryToSubmitRelatedForm.ts", "../../@react-md/utils/src/wia-aria/radio/RadioWidget.tsx", "../../@react-md/utils/src/wia-aria/radio/utils.ts", "../../@react-md/utils/src/wia-aria/useCloseOnEscape.ts", "../../@react-md/utils/src/wia-aria/useScrollLock.ts", "../../@react-md/divider/src/useVerticalDividerHeight.ts", "../../@react-md/divider/src/VerticalDivider.tsx"],
  "sourcesContent": ["/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = '';\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (arg) {\n\t\t\t\tclasses = appendClass(classes, parseValue(arg));\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction parseValue (arg) {\n\t\tif (typeof arg === 'string' || typeof arg === 'number') {\n\t\t\treturn arg;\n\t\t}\n\n\t\tif (typeof arg !== 'object') {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (Array.isArray(arg)) {\n\t\t\treturn classNames.apply(null, arg);\n\t\t}\n\n\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\treturn arg.toString();\n\t\t}\n\n\t\tvar classes = '';\n\n\t\tfor (var key in arg) {\n\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\tclasses = appendClass(classes, key);\n\t\t\t}\n\t\t}\n\n\t\treturn classes;\n\t}\n\n\tfunction appendClass (value, newClass) {\n\t\tif (!newClass) {\n\t\t\treturn value;\n\t\t}\n\t\n\t\tif (value) {\n\t\t\treturn value + ' ' + newClass;\n\t\t}\n\t\n\t\treturn value + newClass;\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n", "import type { ElementType, HTMLAttributes } from \"react\";\nimport { forwardRef } from \"react\";\nimport cn from \"classnames\";\nimport { bem } from \"@react-md/utils\";\n\nexport type DividerElement = HTMLHRElement | HTMLDivElement;\n\nexport interface DividerProps extends HTMLAttributes<DividerElement> {\n  /**\n   * Boolean if the divider should appear inset instead of full width. This\n   * really just applied a margin-left (or margin-right when dir=\"rtl\").\n   *\n   * If you want to create a divider that is centered, you most likely want to\n   * use the `rmd-divider-theme-update-var` mixin instead to update the\n   * `max-size` of the divider.\n   */\n  inset?: boolean;\n\n  /**\n   * Boolean if the divider should be vertical instead of horizontal. This will\n   * change the divider to be rendered as a `<div>` instead of an `<hr>`.\n   *\n   * Note: If your parent element of the divider does not have a static height\n   * set, you **must** manually set the height of the divider to a static\n   * non-percentage number OR use the `VerticalDivider` component instead to\n   * automagically create a valid percentage height.\n   */\n  vertical?: boolean;\n}\n\nconst block = bem(\"rmd-divider\");\n\nexport const Divider = forwardRef<DividerElement, DividerProps>(\n  function Divider(\n    {\n      inset = false,\n      vertical = false,\n      role = \"separator\",\n      className,\n      ...props\n    },\n    ref\n  ) {\n    const Component = (vertical ? \"div\" : \"hr\") as ElementType;\n\n    return (\n      <Component\n        {...props}\n        ref={ref}\n        role={role}\n        className={cn(\n          block({ inset: !vertical && inset, vertical }),\n          className\n        )}\n      />\n    );\n  }\n);\n", "import type { MutableRefObject, Ref } from \"react\";\n\n/**\n * A small utility function that allows me to apply a passed in ref along with\n * my own custom ref logic.\n *\n * @param instance - The DOM Node instance\n * @param ref - The prop ref\n */\nexport function applyRef<E>(instance: E | null, ref?: Ref<E>): void {\n  if (!ref) {\n    return;\n  }\n\n  if (typeof ref === \"function\") {\n    ref(instance);\n  } else if (typeof ref === \"object\") {\n    (ref as MutableRefObject<E | null>).current = instance;\n  }\n}\n", "type Block = string;\ntype Element = string;\ntype Modifier = Record<string, unknown>;\n\nfunction modify(base: string, modifier?: Modifier): string {\n  if (!modifier) {\n    return base;\n  }\n\n  const hasOwn = Object.prototype.hasOwnProperty;\n  return Object.keys(modifier).reduce((s, mod) => {\n    if (hasOwn.call(modifier, mod) && modifier[mod]) {\n      s = `${s} ${base}--${mod}`;\n    }\n\n    return s;\n  }, base);\n}\n\ntype BEMResult = (\n  elementOrModifier?: Element | Modifier,\n  modifier?: Modifier\n) => string;\n\n/**\n * Applies the BEM styled class name to an element.\n *\n * @see https://en.bem.info/methodology/css/\n * @param base - The base class to use\n * @returns a function to call that generates the full class name\n */\nexport function bem(base: Block): BEMResult {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!base) {\n      throw new Error(\n        \"bem requires a base block class but none were provided.\"\n      );\n    }\n  }\n\n  /**\n   * Creates the full class name from the base block name. This can be called\n   * without any arguments which will just return the base block name (kind of\n   * worthless), or you can provide a child element name and modifiers.\n   *\n   * @param elementOrModifier - This is either the child element name or an\n   * object of modifiers to apply. This **must** be a string if the second\n   * argument is provided.\n   * @param modifier - Any optional modifiers to apply to the block and optional\n   * element.\n   * @returns the full class name\n   */\n  return function block(\n    elementOrModifier?: Element | Modifier,\n    modifier?: Modifier\n  ): string {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof elementOrModifier !== \"string\" && modifier) {\n        throw new TypeError(\n          \"bem does not support having two modifier arguments.\"\n        );\n      }\n    }\n\n    if (!elementOrModifier) {\n      return base;\n    }\n\n    if (typeof elementOrModifier !== \"string\") {\n      return modify(base, elementOrModifier);\n    }\n\n    return modify(`${base}__${elementOrModifier}`, modifier);\n  };\n}\n", "import type { ReactElement } from \"react\";\nimport {\n  Children,\n  cloneElement,\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from \"react\";\n\n/**\n * Note: unlike the `dir` DOM attribute, the `\"auto\"` value is not supported\n *\n * @remarks \\@since 2.3.0\n */\nexport type WritingDirection = \"ltr\" | \"rtl\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface WritingDirectionContext {\n  /**\n   * The current writing direction that is being inherited.\n   */\n  dir: WritingDirection;\n\n  /**\n   * Toggles the current writing direction for the first parent `Dir` component.\n   */\n  toggleDir(): void;\n}\n\n/**\n * @internal\n */\ninterface InheritableContext extends WritingDirectionContext {\n  root: boolean;\n}\n\nconst context = createContext<InheritableContext>({\n  root: true,\n  dir: \"ltr\",\n  toggleDir: () => {\n    throw new Error(\n      \"Tried to toggle the current writing direction without initializing the `Dir` component.\"\n    );\n  },\n});\nconst { Provider } = context;\n\n/**\n * Gets the writing direction context which provides access to the current `dir`\n * and a `toggleDir` function.\n *\n * @remarks \\@since 2.3.0\n */\nexport function useDir(): WritingDirectionContext {\n  const { root: _root, ...current } = useContext(context);\n  return current;\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface DirProps {\n  /**\n   * A single ReactElement child. If the `Dir` has a parent `Dir`, the child\n   * will have the `dir` prop cloned into this element.\n   */\n  children: ReactElement;\n\n  /**\n   * The default writing direction for your app or a subtree. To change the\n   * current writing direction, use the `useDir` hook to get access to the\n   * current `dir` and the `toggleDir` function.\n   */\n  defaultDir?: WritingDirection | (() => WritingDirection);\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const DEFAULT_DIR = (): WritingDirection => {\n  let dir: WritingDirection = \"ltr\";\n  if (typeof document !== \"undefined\") {\n    const rootDir = document.documentElement.getAttribute(\"dir\");\n    dir = rootDir === \"rtl\" ? \"rtl\" : \"ltr\";\n  }\n\n  return dir;\n};\n\n/**\n * The `Dir` component is used to handle the current writing direction within\n * your app as well as conditionally updating the writing direction for small\n * sections in your app. When this component is used for the first time near the\n * root of your React component tree, the current direction will be applied to\n * the root `<html>` element. Otherwise the current dir will be cloned into the\n * child element so it can be passed as a prop.\n *\n * ```tsx\n * // html element will be updated to have `dir=\"ltr\"`\n * ReactDOM.render(<Dir><App /></Dir>, root)\n * ```\n *\n * ```tsx\n * // html element will be updated to have `dir=\"rtl\"` while the `<span>` will\n * // now be `<span dir=\"ltr\">`\n * ReactDOM.render(\n *   <Dir defaultDir=\"rtl\">\n *     <Some>\n *       <Other>\n *         <Components>\n *           <Dir defaultDir=\"ltr\">\n *             <span>Content</span>\n *           </Dir>\n *         </Components>\n *       </Other>\n *     </Some>\n *   </Dir>,\n *   root\n * );\n * ```\n *\n * Note: Since the `dir` is cloned into the child element, you need to make sure\n * that the child is either a DOM element or the `dir` prop is passed from your\n * custom component.\n *\n * @remarks \\@since 2.3.0\n */\nexport function Dir({\n  children,\n  defaultDir = DEFAULT_DIR,\n}: DirProps): ReactElement {\n  const { root } = useContext(context);\n  const [dir, setDir] = useState(defaultDir);\n  useEffect(() => {\n    if (!root || typeof document === \"undefined\") {\n      return;\n    }\n\n    document.documentElement.setAttribute(\"dir\", dir);\n\n    return () => {\n      document.documentElement.removeAttribute(\"dir\");\n    };\n  }, [dir, root]);\n\n  const toggleDir = useCallback(() => {\n    setDir((prevDir) => (prevDir === \"ltr\" ? \"rtl\" : \"ltr\"));\n  }, []);\n\n  const value = useMemo<InheritableContext>(\n    () => ({ root: false, dir, toggleDir }),\n    [dir, toggleDir]\n  );\n  let child = Children.only(children);\n  if (!root) {\n    child = cloneElement(child, { dir });\n  }\n\n  return <Provider value={value}>{child}</Provider>;\n}\n", "import { useEffect } from \"react\";\n\nimport { useRefCache } from \"../useRefCache\";\nimport { delegateEvent } from \"./utils\";\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface ScrollListenerHookOptions extends AddEventListenerOptions {\n  /**\n   * The event handler that will be fired when the page scrolls or if any child\n   * element scrolls when the {@link capture} option is `true`.\n   */\n  onScroll: EventListener;\n\n  /** @defaultValue `true` */\n  enabled?: boolean;\n}\n\n/**\n *\n * @remarks \\@since 5.0.0 Moved the `AddEventListenerOptions` to no longer be\n * part of an `options` object.\n */\nexport function useScrollListener({\n  once,\n  passive = true,\n  signal,\n  capture,\n  enabled = true,\n  onScroll,\n}: ScrollListenerHookOptions): void {\n  const scrollHandlerRef = useRefCache(onScroll);\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const eventHandler = delegateEvent(\"scroll\", window, true, {\n      once,\n      passive,\n      signal,\n      capture,\n    });\n    const scrollHandler = scrollHandlerRef.current;\n    eventHandler.add(scrollHandler);\n\n    return () => {\n      eventHandler.remove(scrollHandler);\n    };\n  }, [capture, enabled, once, passive, scrollHandlerRef, signal]);\n}\n", "import { useEffect, useRef } from \"react\";\n\n/**\n * This hook allows you to provide anything that should be \"cached\" and puts it\n * into a ref that'll be updated each render. This is pretty overkill for most\n * places, but it's really nice when you want to create event handlers that\n * shouldn't update if the developer used arrow functions to define callbacks.\n * (A great example is for ref callbacks that *shouldn't* be triggered each\n * render. But that might just be a programming error instead).\n *\n * @param cacheable - The cacheable thing that gets updated after each render.\n * @returns a mutable ref object containing the current cache.\n */\nexport function useRefCache<T>(cacheable: T): { readonly current: T } {\n  const ref = useRef(cacheable);\n  useEffect(() => {\n    ref.current = cacheable;\n  });\n\n  return ref;\n}\n", "/**\n * The amount of time a user must hover an element before the temporary element\n * becomes visible.\n *\n * @remarks \\@since 2.8.0\n */\nexport const DEFAULT_HOVER_MODE_VISIBLE_IN_TIME = 1000;\n\n/**\n * The amount of time the user must no longer hover any element attached to the\n * {@link HoverModeProvider} to disable the hover mode.\n *\n * @remarks \\@since 2.8.0\n */\nexport const DEFAULT_HOVER_MODE_DEACTIVATION_TIME = 1000;\n\n/**\n * The amount of time the user must not hover any element attached to the same\n * instance of the {@link useHoverMode} hook when the using the sticky mode.\n *\n * @remarks \\@since 5.0.0 This was named the\n * `DEFAULT_HOVER_MODE_STICKY_EXIT_TIME` before.\n */\nexport const DEFAULT_HOVER_MODE_EXIT_TIME = 300;\n", "import type { ReactElement, ReactNode } from \"react\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\n\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport {\n  DEFAULT_HOVER_MODE_DEACTIVATION_TIME,\n  DEFAULT_HOVER_MODE_VISIBLE_IN_TIME,\n} from \"./constants\";\nimport type { HoverModeContext } from \"./useHoverModeContext\";\nimport { HoverModeContextProvider } from \"./useHoverModeContext\";\n\n/** @remarks \\@since 2.8.0 */\nexport interface HoverModeConfiguration {\n  /**\n   * Boolean if the hover mode functionality should be disabled.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * The amount of time (in ms) the user must hover an element before the hover\n   * mode is enabled and the visibility is set to `true`.\n   *\n   * @defaultValue {@link DEFAULT_HOVER_MODE_VISIBLE_IN_TIME}\n   */\n  defaultVisibleInTime?: number;\n\n  /**\n   * The amount of time (in ms) the user must not hover any element connected to\n   * the hover mode.\n   *\n   * @defaultValue {@link DEFAULT_HOVER_MODE_DEACTIVATION_TIME}\n   */\n  deactivateTime?: number;\n}\n\n/** @remarks \\@since 2.8.0 */\nexport interface HoverModeProviderProps extends HoverModeConfiguration {\n  children: ReactNode;\n}\n\n/**\n * This component should normally be mounted near the root of your app to enable\n * hover mode for child components. However, it can also be used at other levels\n * if hover mode functionality should not carry over between two different parts\n * of the screen.\n *\n * @example\n * Separating Hover Mode\n * ```tsx\n * export default function Example(): ReactElement {\n *   return (\n *     <>\n *       <HoverModeProvider>\n *         <HeaderActions />\n *       </HoverModeProvider>\n *       <HoverModeProvider>\n *         <MainContent />\n *       </HoverModeProvider>\n *     </>\n *   );\n * }\n * ```\n *\n * @remarks \\@since 2.8.0\n */\nexport function HoverModeProvider({\n  children,\n  disabled = false,\n  defaultVisibleInTime = DEFAULT_HOVER_MODE_VISIBLE_IN_TIME,\n  deactivateTime = DEFAULT_HOVER_MODE_DEACTIVATION_TIME,\n}: HoverModeProviderProps): ReactElement {\n  const [visibleInTime, setVisibleInTime] = useState(defaultVisibleInTime);\n  const timeoutRef = useRef<number>();\n  const enableHoverMode = useCallback(() => {\n    if (disabled) {\n      return;\n    }\n\n    window.clearTimeout(timeoutRef.current);\n    setVisibleInTime(0);\n  }, [disabled]);\n  const disableHoverMode = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n    setVisibleInTime(defaultVisibleInTime);\n  }, [defaultVisibleInTime]);\n\n  const startDisableTimer = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n    timeoutRef.current = window.setTimeout(() => {\n      setVisibleInTime(defaultVisibleInTime);\n    }, deactivateTime);\n  }, [defaultVisibleInTime, deactivateTime]);\n\n  useEffect(() => {\n    if (disabled) {\n      window.clearTimeout(timeoutRef.current);\n      setVisibleInTime(defaultVisibleInTime);\n    }\n  }, [disabled, defaultVisibleInTime]);\n\n  useOnUnmount(() => {\n    window.clearTimeout(timeoutRef.current);\n  });\n\n  const context = useMemo<HoverModeContext>(\n    () => ({\n      visibleInTime,\n      enableHoverMode,\n      disableHoverMode,\n      startDisableTimer,\n    }),\n    [disableHoverMode, enableHoverMode, startDisableTimer, visibleInTime]\n  );\n\n  return (\n    <HoverModeContextProvider value={context}>\n      {children}\n    </HoverModeContextProvider>\n  );\n}\n", "import { useEffect, useRef } from \"react\";\n\n/**\n * A simple hook that only triggers the callback when a component is unmounted.\n * This will make sure that the callback function does not have a stale closure\n * by the time the component unmounts as well.\n *\n * @example\n * Simple Example\n * ```ts\n * useOnUnmount(() => {\n *   console.log('Component is unmounted.');\n * });\n *\n * const [data, setData] = useState(initialData);\n * useOnUnmount(() => {\n *   API.saveCurrentData(data);\n * });\n *\n * // update data\n * ```\n *\n * @remarks \\@since 2.7.1\n * @param callback - the function to call when the component unmounts.\n */\nexport function useOnUnmount(callback: () => void): void {\n  const ref = useRef(callback);\n  useEffect(() => {\n    ref.current = callback;\n  });\n\n  return useEffect(() => () => ref.current(), []);\n}\n", "import { createContext, useContext } from \"react\";\n\nimport { DEFAULT_HOVER_MODE_VISIBLE_IN_TIME } from \"./constants\";\n\n/** @internal */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * This is mostly an internal interface since everything you need will be\n * available in the {@link useHoverMode} hook.\n *\n * @remarks \\@since 2.8.0\n */\nexport interface HoverModeActions {\n  /**\n   * A function that will enable the hover mode for all connected components.\n   * This should normally be called after hovering over an element for the\n   * {@link HoverModeContext.visibleInTime}.\n   */\n  enableHoverMode(): void;\n\n  /**\n   * A function that will disable the hover mode for all connected components.\n   * This should normally be called after leaving a hoverable element or the\n   * {@link UserInteractionMode} changes to `\"touch\"`.\n   */\n  disableHoverMode(): void;\n\n  /**\n   * A function that will start a timer for disabling the hover mode for all\n   * connected components. This should normally be called after leaving a\n   * hoverable element\n   */\n  startDisableTimer(): void;\n}\n\n/**\n * This is mostly an internal interface since everything you need will be\n * available in the {@link useHoverMode} hook.\n *\n * @remarks \\@since 2.8.0\n */\nexport interface HoverModeContext extends HoverModeActions {\n  /**\n   * The amount of time (in ms) before the element being hovered should\n   * switch the visibility from `false` to `true`.\n   */\n  visibleInTime: number;\n}\n\n/** @internal */\nconst context = createContext<HoverModeContext>({\n  visibleInTime: DEFAULT_HOVER_MODE_VISIBLE_IN_TIME,\n  enableHoverMode: noop,\n  disableHoverMode: noop,\n  startDisableTimer: noop,\n});\n\n/**\n * @internal\n * @remarks \\@since 2.8.0\n */\nexport const { Provider: HoverModeContextProvider } = context;\n\n/**\n * Gets the {@link HoverModeContext} which allows you implement hover mode\n * functionality for any component. This is mostly an internal hook since\n * everything you need will be available in the {@link useHoverMode} hook.\n *\n * @internal\n * @remarks \\@since 2.8.0\n * @returns The {@link HoverModeContext}\n */\nexport function useHoverModeContext(): HoverModeContext {\n  return useContext(context);\n}\n", "import type { Dispatch, MouseEvent, SetStateAction } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { useUserInteractionMode } from \"../mode\";\nimport { useOnUnmount } from \"../useOnUnmount\";\nimport { DEFAULT_HOVER_MODE_EXIT_TIME } from \"./constants\";\nimport type { HoverModeActions } from \"./useHoverModeContext\";\nimport { useHoverModeContext } from \"./useHoverModeContext\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseEnter<E extends HTMLElement>(event: MouseEvent<E>): void;\n\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onMouseLeave<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * An object of event handlers that should be provided to a component to enable\n * and disable the visibility of a temporary element while hovering over that\n * component.\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 The `HTMLElement` type will be correctly inferred when\n * using them on multiple components.\n */\nexport interface HoverModeEventHandlers extends HoverModeHoverEventHandlers {\n  /**\n   * An optional event handler to merge with the hover mode visibility handler.\n   * If this function calls `event.stopPropagation()`, the hover mode behavior\n   * will be disabled.\n   */\n  onClick<E extends HTMLElement>(event: MouseEvent<E>): void;\n}\n\n/**\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 No longer has event handlers or a separate \"sticky\" API.\n */\nexport interface HoverModeOptions {\n  /**\n   * Boolean if the hover mode functionality should be disabled.\n   *\n   * @defaultValue `false`\n   */\n  disabled?: boolean;\n\n  /**\n   * Boolean if the element should start visible.\n   *\n   * @defaultValue `false`\n   */\n  defaultVisible?: boolean;\n\n  /**\n   * The amount of time to wait once the mouse has left the element before\n   * setting the visibility to `false`.\n   *\n   * @defaultValue {@link DEFAULT_HOVER_MODE_EXIT_TIME}\n   */\n  exitVisibilityDelay?: number;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface HoverModeHookReturnValue\n  extends HoverModeActions,\n    HoverModeEventHandlers {\n  /**\n   * Boolean if the hover mode is currently working.\n   */\n  active: boolean;\n\n  /**\n   * Boolean if the the `visible` state is `true` because the user clicked an\n   * element.\n   */\n  stuck: boolean;\n\n  /**\n   * Boolean if the temporary element should be visible.\n   */\n  visible: boolean;\n\n  /**\n   * A function to manually set the visibility state if you need even more\n   * custom behavior.\n   */\n  setVisible: Dispatch<SetStateAction<boolean>>;\n\n  /**\n   * A convenience prop that allows you to spread all the hover mode event\n   * handlers onto a single component if no custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  handlers: Readonly<HoverModeEventHandlers>;\n\n  /**\n   * A convenience prop that allows you to spread only the `onMouseEnter` and\n   * `onMouseLeave` the hover mode event handlers onto a single component if no\n   * custom functionality is required.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  hoverHandlers: Readonly<HoverModeHoverEventHandlers>;\n\n  /**\n   * Clears the current `onMouseEnter` visibility timer.\n   *\n   * @remarks \\@since 5.0.0\n   */\n  clearHoverTimeout(): void;\n}\n\n/**\n * This hook is used to add the hover mode functionality to any component.\n *\n * @example\n * Displaying a Color Preview when hovering a Hex Code\n * ```tsx\n * import type { ReactElement } from \"react\";\n * import { CSSTransition } from \"@react-md/transition\";\n * import { useHoverMode } from \"@react-md/utils\";\n *\n * interface Props {\n *   value: string;\n * }\n *\n * export default function Color({ value }: Props): ReactElement {\n *   const { visible, onMouseEnter, onMouseLeave } =\n *     useHoverMode({ exitVisibilityDelay: 0 });\n *\n *   return (\n *     <>\n *       <span\n *         onMouseEnter={onMouseEnter}\n *         onMouseLeave={onMouseLeave}\n *         style={{\n *           // pretend styles\n *         }}\n *       >\n *         {value}\n *       </span>\n *       <CSSTransition\n *         transitionIn={visible}\n *         classNames=\"opacity-change\"\n *         timeout={150}\n *         temporary\n *       >\n *         <span\n *           style={{\n *             backgroundColor: value,\n *             // other styles\n *           }}\n *         />\n *      </CSSTransition>\n *     </>\n *   );\n * }\n * ```\n *\n * @example\n * Sticky Usage with a Fixed Dialog\n * ```tsx\n * const {\n *   stuck,\n *   active,\n *   visible,\n *   setVisible,\n *   handlers,\n *   hoverHandlers,\n * } = useHoverMode();\n * const buttonRef = useRef<HTMLButtonElement>(null);\n *\n * return (\n *   <>\n *     <Button {...handlers} ref={buttonRef}>\n *       Click Me\n *     </Button>\n *     <FixedDialog\n *       {...hoverHandlers}\n *       aria-labelledby=\"dialog-title-id\"\n *       id=\"dialog-id\"\n *       visible={visible}\n *       onRequestClose={() => setVisible(false)}\n *       fixedTo={buttonRef}\n *       anchor={BELOW_CENTER_ANCHOR}\n *       options={{ preventOverlap: true }}\n *       // this allows the close on outside click\"\" behavior\" to work\n *       overlay={!stuck && active ? false : undefined}\n *       disableScrollLock={active}\n *     >\n *       <YourDialogContent />\n *    </FixedDialog>\n *   </>\n * );\n * ```\n *\n * @remarks \\@since 2.8.0\n * @remarks \\@since 5.0.0 This hook no longer returns `handlers` or\n * `stickyHandlers` and does not hide when an element on the page is clicked.\n * @param options - An optional object of options to use. See\n * {@link HoverModeOptions} for more details.\n * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}\n */\nexport function useHoverMode({\n  disabled = false,\n  defaultVisible = false,\n  exitVisibilityDelay = DEFAULT_HOVER_MODE_EXIT_TIME,\n}: HoverModeOptions = {}): HoverModeHookReturnValue {\n  const mode = useUserInteractionMode();\n  const isTouch = mode === \"touch\";\n  const [visible, setVisible] = useState(defaultVisible);\n  const [stuck, setStuck] = useState(false);\n  const timeoutRef = useRef<number>();\n  const {\n    visibleInTime,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n  } = useHoverModeContext();\n  const active = visibleInTime === 0;\n\n  useEffect(() => {\n    if (!visible) {\n      setStuck(false);\n    }\n  }, [visible]);\n\n  useOnUnmount(() => {\n    window.clearTimeout(timeoutRef.current);\n  });\n\n  const clearHoverTimeout = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n  }, []);\n\n  const onMouseEnter = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      clearHoverTimeout();\n      if (visibleInTime === 0) {\n        enableHoverMode();\n        setVisible(true);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        enableHoverMode();\n        setVisible(true);\n      }, visibleInTime);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      enableHoverMode,\n      isTouch,\n      stuck,\n      visibleInTime,\n    ]\n  );\n\n  const onMouseLeave = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (stuck || disabled || isTouch || event.isPropagationStopped()) {\n        return;\n      }\n\n      startDisableTimer();\n      clearHoverTimeout();\n      if (exitVisibilityDelay === 0) {\n        setVisible(false);\n        return;\n      }\n\n      timeoutRef.current = window.setTimeout(() => {\n        setVisible(false);\n      }, exitVisibilityDelay);\n    },\n    [\n      clearHoverTimeout,\n      disabled,\n      exitVisibilityDelay,\n      isTouch,\n      startDisableTimer,\n      stuck,\n    ]\n  );\n\n  const onClick = useCallback(\n    <E extends HTMLElement>(event: MouseEvent<E>) => {\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      // If the hover mode functionality is disabled, just allow this to behave\n      // like a toggle visibility handler.\n      if (!stuck && !disabled) {\n        setStuck(true);\n        setVisible(true);\n      } else {\n        setStuck(false);\n        setVisible((prevVisible) => !prevVisible);\n      }\n    },\n    [disabled, stuck]\n  );\n\n  return {\n    active,\n    stuck,\n    visible,\n    setVisible,\n    onClick,\n    onMouseEnter,\n    onMouseLeave,\n    enableHoverMode,\n    disableHoverMode,\n    startDisableTimer,\n    clearHoverTimeout,\n    handlers: {\n      onClick,\n      onMouseEnter,\n      onMouseLeave,\n    },\n    hoverHandlers: {\n      onMouseEnter,\n      onMouseLeave,\n    },\n  };\n}\n", "import type { ReactElement, ReactNode } from \"react\";\nimport { createContext, useContext } from \"react\";\n\nimport type { UserInteractionMode } from \"./types\";\nimport { useInteractionMode } from \"./useInteractionMode\";\n\n/**\n * @internal\n */\nconst modeContext = createContext<UserInteractionMode>(\"mouse\");\n\n/**\n * @internal\n */\nconst parentContext = createContext(false);\n\n/**\n * @internal\n */\nconst { Provider: UserInteractionModeProvider } = modeContext;\n\n/**\n * @internal\n */\nconst { Provider: ParentProvider } = parentContext;\n\n/**\n * Returns the current user interaction mode.\n *\n * @returns {@link UserInteractionMode}\n */\nexport function useUserInteractionMode(): UserInteractionMode {\n  return useContext(modeContext);\n}\n\n/**\n * Example:\n *\n * ```ts\n * const isKeyboard = useIsUserInteractionMode(\"keyboard\");\n * // do stuff if keyboard only\n * ```\n *\n * @param mode - The {@link UserInteractionMode} to check against.\n * @returns `true` if the current user interaction mode matches the provided\n * mode.\n */\nexport function useIsUserInteractionMode(mode: UserInteractionMode): boolean {\n  return useUserInteractionMode() === mode;\n}\n\nexport interface UserInteractionModeListenerProps {\n  /**\n   * The `children` are required since this component basically does nothing\n   * other than providing a `className` to the `document.body` otherwise.\n   */\n  children: ReactNode;\n}\n\n/**\n * This component is used to determine how the user is current interacting with\n * your app as well as modifying the `document.body`'s `className` with the\n * current mode. This is what allows the `rmd-utils-phone-only`,\n * `rmd-utils-keyboard-only`, and `rmd-utils-mouse-only` mixins to work.\n *\n * @remarks \\@since 2.6.0 Renamed from `InteractionModeListener`\n * @throws When this component has been mounted multiple times in your app.\n */\nexport function UserInteractionModeListener({\n  children,\n}: UserInteractionModeListenerProps): ReactElement {\n  const mode = useInteractionMode();\n  if (useContext(parentContext)) {\n    throw new Error(\n      \"Mounted multiple `UserInteractionModeListener` components.\"\n    );\n  }\n\n  return (\n    <UserInteractionModeProvider value={mode}>\n      <ParentProvider value>{children}</ParentProvider>\n    </UserInteractionModeProvider>\n  );\n}\n", "import { useRef, useState } from \"react\";\n\nimport type { UserInteractionMode } from \"./types\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @internal\n */\nconst TOUCH_TIMEOUT = 1200;\n\n/**\n * This hook helps determine the current interaction mode by attaching the\n * required event listeners to the window. The `mode` will always be defaulted\n * to `mouse` at first since it has the least possibilities of causing errors\n * with styles since the mouse-only styles are normally just `:hover` effects.\n *\n * ## Switching between modes:\n *\n * ### While in `mouse` mode:\n *\n * - any `keydown` event will switch to `keyboard` mode\n *   - this does have the side effect of meta keys also causing the switch over,\n *     but it feels fine since it helps show the current focus in the document\n *     as well\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `keyboard` mode:\n *\n * - any `mousedown` event will switch to `mouse` mode\n *   - it is perfectly okay to move the mouse while in keyboard mode, but still\n *     want to keep the keyboard styles until the user actually starts clicking\n * - any `touchstart` event will switch to `touch` mode\n *\n * ### While in `touch` mode:\n *\n * - any `mousemove` event will switch to `mouse` mode, but **only** if there\n *   hasn't been a `contextmenu` event within the last `1.2s`\n *   - you can really only switch back to `mouse` mode if you are using the\n *     devtools to emulate devices OR using a touch-desktop. I don't know how\n *     common this really is though.\n *   - touching the screen will always fire a `mousemove` event (which is why\n *     the `:hover` styles are normally with `rmd-utils-mouse-only`) and even\n *     after the `contextmenu` event. Normally want to go back to `mouse` mode\n *     when the mouse re-enters the `window`\n *\n * Note: It's currently impossible to switch from `touch` to `keyboard`\n * immediately. You'd first need to switch to `mouse` and then to `keyboard`. I\n * don't really know of any use-cases other than the weird touch-desktop stuff\n * and I have no experience using them.\n *\n * @internal\n */\nexport function useInteractionMode(): UserInteractionMode {\n  const [mode, setMode] = useState<UserInteractionMode>(\"mouse\");\n  const lastTouchTime = useRef(0);\n  const isTouchContextMenu = useRef(false);\n\n  useIsomorphicLayoutEffect(() => {\n    const enableMouseMode = (): void => setMode(\"mouse\");\n    const enableKeyboardMode = (): void => setMode(\"keyboard\");\n\n    const handleTouchStart = (): void => {\n      lastTouchTime.current = Date.now();\n      isTouchContextMenu.current = false;\n      setMode(\"touch\");\n    };\n\n    const handleMouseMove = (): void => {\n      if (\n        isTouchContextMenu.current ||\n        Date.now() - lastTouchTime.current < TOUCH_TIMEOUT\n      ) {\n        isTouchContextMenu.current = false;\n        return;\n      }\n\n      enableMouseMode();\n    };\n    const handleContextMenu = (): void => {\n      isTouchContextMenu.current = true;\n    };\n\n    const className = `rmd-utils--${mode}`;\n    document.body.classList.add(className);\n    window.addEventListener(\"touchstart\", handleTouchStart, true);\n    if (mode === \"mouse\") {\n      window.addEventListener(\"keydown\", enableKeyboardMode, true);\n    } else if (mode === \"keyboard\") {\n      window.addEventListener(\"mousedown\", enableMouseMode, true);\n    } else {\n      window.addEventListener(\"mousemove\", handleMouseMove, true);\n      window.addEventListener(\"contextmenu\", handleContextMenu, true);\n    }\n\n    return () => {\n      document.body.classList.remove(className);\n      window.removeEventListener(\"touchstart\", handleTouchStart, true);\n      if (mode === \"mouse\") {\n        window.removeEventListener(\"keydown\", enableKeyboardMode, true);\n      } else if (mode === \"keyboard\") {\n        window.removeEventListener(\"mousedown\", enableMouseMode, true);\n      } else {\n        window.removeEventListener(\"mousemove\", handleMouseMove, true);\n        window.removeEventListener(\"contextmenu\", handleContextMenu, true);\n      }\n    };\n  }, [mode]);\n\n  return mode;\n}\n", "import { useEffect, useLayoutEffect } from \"react\";\n\n/**\n * This is copy/pasted from react-redux which has some more information about\n * this and how to fix \"invalid\" warnings while running tests.\n *\n * @see https://github.com/reduxjs/react-redux/blob/4c907c0870c6b9a136dd69be294c17d1dc63c8f5/src/utils/useIsomorphicLayoutEffect.js\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== \"undefined\" &&\n  typeof window.document !== \"undefined\" &&\n  typeof window.document.createElement !== \"undefined\"\n    ? useLayoutEffect\n    : useEffect;\n", "import type { Dispatch, SetStateAction } from \"react\";\nimport { createContext, useContext } from \"react\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport interface ActiveDescendantContext {\n  activeId: string;\n  setActiveId: Dispatch<SetStateAction<string>>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nconst context = createContext<ActiveDescendantContext>({\n  activeId: \"\",\n  setActiveId() {\n    throw new Error(\n      \"ActiveDescendantMovementProvider must be a parent component.\"\n    );\n  },\n});\ncontext.displayName = \"ActiveDescendant\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const { Provider: ActiveDescendantContextProvider } = context;\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function useActiveDescendantContext(): Readonly<ActiveDescendantContext> {\n  return useContext(context);\n}\n", "import type { ReactElement, ReactNode } from \"react\";\nimport { useMemo } from \"react\";\nimport type { ActiveDescendantContext } from \"./activeDescendantContext\";\nimport { ActiveDescendantContextProvider } from \"./activeDescendantContext\";\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface ActiveDescendantMovementProviderProps\n  extends ActiveDescendantContext {\n  children: ReactNode;\n}\n\n/**\n * This component should be used with the {@link KeyboardMovementProvider}\n * component to implement custom keyboard focusable behavior using\n * `aria-activedescendant`.\n *\n * @example\n * Base Example\n * ```tsx\n * function Descendant({ id, children, ...props }: HTMLAttributes<HTMLDivElement>): ReactElement {\n *   const { ref, active } = useActiveDescendant({ id });\n *   return (\n *     <div\n *       {...props}\n *       id={id}\n *       ref={ref}\n *       role=\"option\"\n *       tabIndex={-1}\n *       className={active ? \"active\" : undefined}\n *     >\n *       {children}\n *     </div>\n *   );\n * }\n *\n * function CustomFocus(): ReactElement {\n *   const { providerProps, focusIndex, ...containerProps } =\n *     useActiveDescendantFocus()\n *\n *   return (\n *     <ActiveDescendantMovementProvider>\n *       <div\n *         {...containerProps}\n *         id=\"some-unique-id\"\n *         role=\"listbox\"\n *         tabIndex={0}\n *       >\n *         <Descendant id=\"some-descendant-id\">\n *           Some Option\n *         </Descendant>\n *       </div>\n *      </ActiveDescendantMovementProvider>\n *   );\n * }\n *\n * function Example() {\n *   return (\n *     <KeyboardMovementProvider loopable searchable>\n *       <CustomFocus />\n *     </KeyboardMovementProvider>\n *   );\n * }\n * ```\n *\n * @see https://www.w3.org/TR/wai-aria-practices/#kbd_focus_activedescendant\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function ActiveDescendantMovementProvider({\n  children,\n  activeId,\n  setActiveId,\n}: ActiveDescendantMovementProviderProps): ReactElement {\n  return (\n    <ActiveDescendantContextProvider\n      value={useMemo(\n        () => ({\n          activeId,\n          setActiveId,\n        }),\n        [activeId, setActiveId]\n      )}\n    >\n      {children}\n    </ActiveDescendantContextProvider>\n  );\n}\n", "import type { ReactElement, ReactNode } from \"react\";\nimport { useMemo, useRef } from \"react\";\n\nimport { useDir } from \"../Dir\";\nimport {\n  DEFAULT_KEYBOARD_MOVEMENT,\n  DEFAULT_LTR_KEYBOARD_MOVEMENT,\n  DEFAULT_RTL_KEYBOARD_MOVEMENT,\n  KeyboardMovementContextProvider,\n} from \"./movementContext\";\nimport type {\n  KeyboardFocusContext,\n  KeyboardFocusElementData,\n  KeyboardMovementBehavior,\n  KeyboardMovementConfig,\n  KeyboardMovementConfiguration,\n} from \"./types\";\nimport { getSearchText } from \"./utils\";\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardMovementProviderProps\n  extends KeyboardMovementBehavior,\n    KeyboardMovementConfiguration {\n  children: ReactNode;\n}\n\n/**\n * @example\n * Main Usage\n * ```tsx\n * function Example() {\n *   return (\n *     <KeyboardMovementProvider>\n *       <CustomKeyboardFocusWidget />\n *     </KeyboardMovementProvider>\n *   );\n * }\n *\n * function CustomKeyboardFocusWidget() {\n *   const { focusIndex: _focusIndex, ...eventHandlers } = useKeyboardFocus();\n *   return (\n *     <div {...eventHandlers}>\n *       <FocusableChild />\n *       <FocusableChild />\n *       <FocusableChild />\n *       <FocusableChild />\n *     </div>\n *   );\n * }\n *\n * function FocusableChild() {\n *   const refCallback = useKeyboardFocusableElement()\n *\n *   return <div role=\"menuitem\" tabIndex={-1} ref={refCallback}>Content</div>;\n * }\n * ```\n *\n * @remarks \\@since 5.0.0\n */\nexport function KeyboardMovementProvider({\n  children,\n  loopable = false,\n  searchable = false,\n  horizontal = false,\n  includeDisabled = false,\n  incrementKeys: propIncrementKeys,\n  decrementKeys: propDecrementKeys,\n  jumpToFirstKeys: propJumpToFirstKeys,\n  jumpToLastKeys: propJumpToLastKeys,\n}: KeyboardMovementProviderProps): ReactElement {\n  const isRTL = useDir().dir === \"rtl\";\n  let defaults: Readonly<Required<KeyboardMovementConfiguration>>;\n  if (horizontal) {\n    defaults = isRTL\n      ? DEFAULT_RTL_KEYBOARD_MOVEMENT\n      : DEFAULT_LTR_KEYBOARD_MOVEMENT;\n  } else {\n    defaults = DEFAULT_KEYBOARD_MOVEMENT;\n  }\n\n  const incrementKeys = propIncrementKeys || defaults.incrementKeys;\n  const decrementKeys = propDecrementKeys || defaults.decrementKeys;\n  const jumpToFirstKeys = propJumpToFirstKeys || defaults.jumpToFirstKeys;\n  const jumpToLastKeys = propJumpToLastKeys || defaults.jumpToLastKeys;\n\n  const watching = useRef<KeyboardFocusElementData[]>([]);\n  const configuration: KeyboardMovementConfig = {\n    incrementKeys,\n    decrementKeys,\n    jumpToFirstKeys,\n    jumpToLastKeys,\n  };\n  const config = useRef(configuration);\n  config.current = configuration;\n\n  const value = useMemo<KeyboardFocusContext>(\n    () => ({\n      attach(element) {\n        watching.current.push({\n          element,\n          content: getSearchText(element, searchable),\n        });\n      },\n      detach(element) {\n        watching.current = watching.current.filter(\n          (cache) => cache.element !== element\n        );\n      },\n      watching,\n      config,\n      loopable,\n      searchable,\n      horizontal,\n      includeDisabled: includeDisabled,\n    }),\n    [horizontal, includeDisabled, loopable, searchable]\n  );\n\n  return (\n    <KeyboardMovementContextProvider value={value}>\n      {children}\n    </KeyboardMovementContextProvider>\n  );\n}\n", "import { createContext, useContext } from \"react\";\n\nimport type { KeyboardFocusContext, KeyboardMovementConfig } from \"./types\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nconst noop = (): void => {\n  if (process.env.NODE_ENV !== \"production\") {\n    throw new Error(\"KeyboardMovementProvider must be a parent component.\");\n  }\n};\n\n/**\n * Most custom keyboard functionality use these keys.\n *\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const DEFAULT_KEYBOARD_MOVEMENT: Readonly<KeyboardMovementConfig> = {\n  incrementKeys: [\"ArrowDown\"],\n  decrementKeys: [\"ArrowUp\"],\n  jumpToFirstKeys: [\"Home\"],\n  jumpToLastKeys: [\"End\"],\n};\n\n/**\n * @remarks \\@since 5.1.2\n * @internal\n */\nexport const DEFAULT_LTR_KEYBOARD_MOVEMENT: Readonly<KeyboardMovementConfig> = {\n  incrementKeys: [\"ArrowRight\"],\n  decrementKeys: [\"ArrowLeft\"],\n  jumpToFirstKeys: [\"Home\"],\n  jumpToLastKeys: [\"End\"],\n};\n\n/**\n * @remarks \\@since 5.1.2\n * @internal\n */\nexport const DEFAULT_RTL_KEYBOARD_MOVEMENT: Readonly<KeyboardMovementConfig> = {\n  incrementKeys: [\"ArrowLeft\"],\n  decrementKeys: [\"ArrowRight\"],\n  jumpToFirstKeys: [\"Home\"],\n  jumpToLastKeys: [\"End\"],\n};\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nconst context = createContext<KeyboardFocusContext>({\n  attach: noop,\n  detach: noop,\n  watching: { current: [] },\n  loopable: false,\n  searchable: false,\n  horizontal: false,\n  includeDisabled: false,\n  config: { current: DEFAULT_KEYBOARD_MOVEMENT },\n});\ncontext.displayName = \"KeyboardMovement\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport const { Provider: KeyboardMovementContextProvider } = context;\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nexport function useKeyboardFocusContext(): Readonly<KeyboardFocusContext> {\n  return useContext(context);\n}\n", "/**\n * @remarks \\@since 2.7.0\n */\nexport interface LoopOptions {\n  /**\n   * The current value that should be modified.\n   */\n  value: number;\n\n  /**\n   * An optional `min` value that can be used before looping to the `max` value.\n   *\n   * @defaultValue `0`\n   */\n  min?: number;\n\n  /**\n   * The max number that can be used before looping to the `min` value.\n   */\n  max: number;\n\n  /**\n   * Boolean if the `value` should be incremented or decremented by `1`.\n   */\n  increment: boolean;\n\n  /**\n   * Boolean if the looping should be ignored and only the `min`/`max` options\n   * should be respected. In other words, the looping  behavior will be disabled\n   * and the `value` must be: `min >= value <= max`\n   */\n  minmax?: boolean;\n}\n\n/**\n * A small util that is used to increment or decrement a number until it reaches\n * the max value or -1. When that happens, it will loop around to 0 or the max\n * value respectively. This does not work for different increment numbers or any\n * values below 0 for now.\n *\n * @internal\n * @param options - {@link LoopOptions}\n * @remarks \\@since 2.7.0 The `min` option was added and the arguments changed to an\n * object\n */\nexport function loop({\n  value,\n  min = 0,\n  max,\n  increment,\n  minmax = false,\n}: LoopOptions): number {\n  let next = value + (increment ? 1 : -1);\n  if (minmax) {\n    next = Math.min(max, Math.max(min, next));\n  } else if (next > max) {\n    next = min;\n  } else if (next < min) {\n    next = max;\n  }\n\n  return next;\n}\n", "import type { Ref, RefCallback } from \"react\";\nimport { useCallback, useRef } from \"react\";\n\nimport { applyRef } from \"../applyRef\";\nimport { useKeyboardFocusContext } from \"./movementContext\";\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function useKeyboardFocusableElement<E extends HTMLElement>(\n  ref?: Ref<E>\n): RefCallback<E> {\n  const { attach, detach } = useKeyboardFocusContext();\n  const nodeRef = useRef<E | null>(null);\n\n  return useCallback(\n    (instance: E | null) => {\n      applyRef(instance, ref);\n      if (instance) {\n        attach(instance);\n      } else if (nodeRef.current) {\n        detach(nodeRef.current);\n      }\n\n      nodeRef.current = instance;\n    },\n    [attach, detach, ref]\n  );\n}\n", "import { useState } from \"react\";\n\nimport type { ActiveDescendantContext } from \"./activeDescendantContext\";\nimport type {\n  KeyboardFocusCallbacks,\n  KeyboardFocusHookReturnValue,\n} from \"./useKeyboardFocus\";\nimport { useKeyboardFocus } from \"./useKeyboardFocus\";\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface ActiveDescendantFocusHookOptions<E extends HTMLElement>\n  extends KeyboardFocusCallbacks<E> {\n  /**\n   * An optional DOM id for one of the children that should be focused by\n   * default.\n   */\n  defaultActiveId?: string;\n}\n\n/**\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport interface ActiveDescendantFocusHookReturnValue<E extends HTMLElement>\n  extends KeyboardFocusHookReturnValue<E> {\n  /**\n   * The current DOM id of a child that has keyboard focus.\n   */\n  \"aria-activedescendant\": string;\n\n  /**\n   * An object of props that should be passed to the\n   * {@link ActiveDescendantMovementProvider}.\n   */\n  providerProps: Readonly<ActiveDescendantContext>;\n}\n\n/**\n * @see {@link ActiveDescendantMovementProvider} for an example\n * @internal\n * @remarks \\@since 5.0.0\n */\nexport function useActiveDescendantFocus<E extends HTMLElement>({\n  defaultActiveId = \"\",\n  ...options\n}: ActiveDescendantFocusHookOptions<E> = {}): ActiveDescendantFocusHookReturnValue<E> {\n  const [activeId, setActiveId] = useState(defaultActiveId);\n  return {\n    ...useKeyboardFocus({\n      ...options,\n      onFocusChange(element) {\n        setActiveId(element.id);\n      },\n      getDefaultFocusIndex(elements) {\n        if (!activeId) {\n          return -1;\n        }\n\n        return elements.findIndex(({ id }) => id === activeId);\n      },\n    }),\n    \"aria-activedescendant\": activeId,\n    providerProps: {\n      activeId,\n      setActiveId,\n    },\n  };\n}\n", "import type {\n  FocusEventHandler,\n  KeyboardEvent,\n  KeyboardEventHandler,\n  MutableRefObject,\n} from \"react\";\nimport { useRef } from \"react\";\nimport { useUserInteractionMode } from \"../mode/UserInteractionModeListener\";\n\nimport { findMatchIndex } from \"../search/findMatchIndex\";\nimport { useKeyboardFocusContext } from \"./movementContext\";\nimport {\n  focusElement,\n  getFirstFocusableIndex,\n  getLastFocusableIndex,\n  getNextFocusableIndex,\n  isNotFocusable,\n} from \"./utils\";\n\n/**\n * @remarks \\@since 5.0.0\n * @internal\n */\nconst noop = (): void => {\n  // do nothing\n};\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusArg<E extends HTMLElement> {\n  /**\n   * The keyboard key/letter that was pressed. (`event.key`).\n   */\n  key: string;\n\n  /**\n   * The keyboard event.\n   */\n  event: KeyboardEvent<E>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport type KeyboardFocusHandler<E extends HTMLElement> = (\n  arg: KeyboardFocusArg<E>\n) => void;\n\n/**\n * Optional event handlers that can be called for specific custom focus\n * behavior. If any of these functions call `event.stopPropagation()`, the\n * default focus behavior will not occur.\n *\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusCallbacks<E extends HTMLElement> {\n  onFocus?: FocusEventHandler<E>;\n  onKeyDown?: KeyboardEventHandler<E>;\n\n  /**\n   * This is called whenever a single letter has been pressed and\n   * {@link KeyboardMovementBehavior.searchable} is `true`.\n   */\n  onSearch?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.incrementKeys} are pressed.\n   */\n  onIncrement?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.decrementKeys} are pressed.\n   */\n  onDecrement?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.jumpToFirstKeys} are pressed.\n   */\n  onJumpToFirst?: KeyboardFocusHandler<E>;\n\n  /**\n   * This is called whenever one of the\n   * {@link KeyboardMovementBehavior.jumpToLastKeys} are pressed.\n   */\n  onJumpToLast?: KeyboardFocusHandler<E>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport interface KeyboardFocusHookOptions<E extends HTMLElement>\n  extends KeyboardFocusCallbacks<E> {\n  /**\n   * A function that can be used to get the default focus index when the\n   * container element first gains focus. If this returns `-1`, no child element\n   * will be focused and the container will maintain focus instead.\n   *\n   * @param elements - The current list of elements that can be focused within\n   * the container element\n   * @param container - The container element that gained focus\n   */\n  getDefaultFocusIndex?(elements: readonly HTMLElement[], container: E): number;\n\n  /**\n   * An optional function to call when the custom focused element should change.\n   * The default value is just to call `element.focus()`.\n   *\n   * @param element - The element that should gain custom focus\n   * @param nextFocusIndex - The next focus index which can be used for\n   * additional movement behavior.\n   */\n  onFocusChange?(element: HTMLElement, nextFocusIndex: number): void;\n}\n\n/** @remarks \\@since 5.0.0 */\nexport interface KeyboardFocusHookReturnValue<E extends HTMLElement> {\n  onFocus: FocusEventHandler<E>;\n  onKeyDown: KeyboardEventHandler<E>;\n  focusIndex: MutableRefObject<number>;\n}\n\n/**\n * @remarks \\@since 5.0.0\n */\nexport function useKeyboardFocus<E extends HTMLElement>(\n  options: KeyboardFocusHookOptions<E> = {}\n): KeyboardFocusHookReturnValue<E> {\n  const {\n    onFocus = noop,\n    onKeyDown = noop,\n    onSearch = noop,\n    onIncrement = noop,\n    onDecrement = noop,\n    onJumpToFirst = noop,\n    onJumpToLast = noop,\n    onFocusChange = focusElement,\n    getDefaultFocusIndex,\n  } = options;\n  const mode = useUserInteractionMode();\n  const focusIndex = useRef(-1);\n  const { config, loopable, searchable, watching, includeDisabled } =\n    useKeyboardFocusContext();\n\n  return {\n    focusIndex,\n    onFocus(event) {\n      onFocus(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      if (event.target !== event.currentTarget) {\n        const i = watching.current.findIndex(\n          ({ element }) => element === event.target\n        );\n        if (i !== -1) {\n          focusIndex.current = i;\n        }\n        return;\n      }\n\n      let defaultFocusIndex: number;\n      if (getDefaultFocusIndex) {\n        defaultFocusIndex = getDefaultFocusIndex(\n          watching.current.map(({ element }) => element),\n          event.currentTarget\n        );\n      } else {\n        defaultFocusIndex = getFirstFocusableIndex(\n          watching.current,\n          includeDisabled\n        );\n      }\n\n      // this makes it so that if you click the container element without\n      // clicking any child, it doesn't focus the first element again\n      if (defaultFocusIndex === -1 || mode !== \"keyboard\") {\n        return;\n      }\n\n      focusIndex.current = defaultFocusIndex;\n      const element = watching.current[focusIndex.current]?.element;\n      element && onFocusChange(element, focusIndex.current);\n    },\n    onKeyDown(event) {\n      onKeyDown(event);\n      if (event.isPropagationStopped()) {\n        return;\n      }\n\n      const { key, altKey, ctrlKey, metaKey, shiftKey } = event;\n      const { incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys } =\n        config.current;\n\n      const update = (index: number): void => {\n        event.preventDefault();\n        event.stopPropagation();\n        if (focusIndex.current === index) {\n          return;\n        }\n\n        focusIndex.current = index;\n\n        const element = watching.current[index]?.element;\n        element && onFocusChange(element, focusIndex.current);\n      };\n\n      if (\n        searchable &&\n        key.length === 1 &&\n        // can't search with space since it is generally a click event\n        key !== \" \" &&\n        !altKey &&\n        !ctrlKey &&\n        !metaKey &&\n        !shiftKey\n      ) {\n        onSearch({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        const values = watching.current.map(({ content, element }) => {\n          if (isNotFocusable(element, includeDisabled)) {\n            return \"\";\n          }\n\n          return content;\n        });\n\n        update(findMatchIndex(key, values, focusIndex.current));\n      } else if (jumpToFirstKeys.includes(key)) {\n        onJumpToFirst({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(getFirstFocusableIndex(watching.current, includeDisabled));\n      } else if (jumpToLastKeys.includes(key)) {\n        onJumpToLast({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(getLastFocusableIndex(watching.current, includeDisabled));\n      } else if (incrementKeys.includes(key)) {\n        onIncrement({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(\n          getNextFocusableIndex({\n            loopable,\n            watching: watching.current,\n            increment: true,\n            includeDisabled,\n            currentFocusIndex: focusIndex.current,\n          })\n        );\n      } else if (decrementKeys.includes(key)) {\n        onDecrement({ key, event });\n        if (event.isPropagationStopped()) {\n          return;\n        }\n\n        update(\n          getNextFocusableIndex({\n            loopable,\n            watching: watching.current,\n            increment: false,\n            includeDisabled,\n            currentFocusIndex: focusIndex.current,\n          })\n        );\n      }\n    },\n  };\n}\n", "import type { HTMLAttributes } from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport const GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport const GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\n\nexport interface GridProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if the `children` should have the grid `style` and `className`\n   * props cloned using `React.cloneElement`. This is useful if you just want to\n   * use the grid styles without the additional wrapper `<div>`.\n   *\n   * Note: if this prop is provided, all of the `HTMLAttributes` props will be\n   * ignored as well as the `clone` and `wrapOnly` props.\n   *\n   * @remarks \\@since 2.3.0\n   */\n  cloneStyles?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component and clone the `className` into each child automatically. This is\n   * really just a convenience prop so you don't always need to import both the\n   * `Grid` and `GridCell` components to create a grid.\n   */\n  clone?: boolean;\n\n  /**\n   * Boolean if the `children` should be updated to be wrapped in the `GridCell`\n   * component.  This is really just a convenience prop so you don't always need\n   * to import both the `Grid` and `GridCell` components to create a grid/\n   */\n  wrapOnly?: boolean;\n\n  /**\n   * This prop allows you to generate your grid with a dynamic amount of columns\n   * instead of a static size. This will update the grid to ignore all the\n   * `columns` props and update the grid to show as many columns as possible by\n   * updating the `grid-template-columns` style to be:\n   *\n   * ```scss\n   * grid-template-columns: repeat(auto-fill, minmax($min-cell-width, 1fr));\n   * ```\n   *\n   * This **needs to be a number with a unit**. Check out the documentation on\n   * the `minmax` css function for some more info.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/minmax\n   */\n  minCellWidth?: \"min-content\" | \"max-content\" | \"auto\" | string;\n\n  /**\n   * An optional number of columns to apply for all media types. Providing one\n   * of the media-specific column props will override this value for those\n   * breakpoints still.\n   */\n  columns?: number;\n\n  /**\n   * An optional number of columns to display for phones.\n   */\n  phoneColumns?: number;\n\n  /**\n   * An optional number of columns to display for tablets.\n   */\n  tabletColumns?: number;\n\n  /**\n   * An optional number of columns to display for desktop screens.\n   */\n  desktopColumns?: number;\n\n  /**\n   * An optional number of columns to display for large desktop screens.\n   */\n  largeDesktopColumns?: number;\n\n  /**\n   * This is really just a pass-through of the `style` prop that allows you to\n   * quickly update the base padding for the grid.\n   */\n  padding?: number | string;\n\n  /**\n   * This will override the default grid cell's gutter value (the space between\n   * each cell). This **needs to be a number with a unit** since it is set to a\n   * css variable. Examples:\n   *\n   * - `1rem`\n   * - `16px`\n   * - `1em`\n   * - `5%`\n   */\n  gutter?: string;\n}\n\ntype CSSProperties = React.CSSProperties & {\n  [GRID_GUTTER_VAR]?: string;\n  [GRID_COLUMNS_VAR]?: number;\n};\n\nconst block = bem(\"rmd-grid\");\n\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport const Grid = forwardRef<HTMLDivElement, GridProps>(function Grid(\n  {\n    style,\n    className,\n    children,\n    clone = false,\n    cloneStyles = false,\n    wrapOnly = false,\n    columns,\n    phoneColumns,\n    tabletColumns,\n    desktopColumns,\n    largeDesktopColumns,\n    padding,\n    gutter,\n    minCellWidth,\n    ...props\n  },\n  ref\n) {\n  const { isPhone, isTablet, isDesktop, isLargeDesktop } = useAppSize();\n\n  const mergedStyle: CSSProperties = {\n    padding: (padding !== 0 && padding) || undefined,\n    gridTemplateColumns: minCellWidth\n      ? `repeat(auto-fill, minmax(${minCellWidth}, 1fr))`\n      : undefined,\n    ...style,\n    [GRID_COLUMNS_VAR]:\n      (isPhone && phoneColumns) ||\n      (isTablet && tabletColumns) ||\n      (isLargeDesktop && largeDesktopColumns) ||\n      (isDesktop && desktopColumns) ||\n      columns,\n    [GRID_GUTTER_VAR]: gutter,\n  };\n  const mergedClassName = cn(block({ \"no-padding\": padding === 0 }), className);\n\n  if (cloneStyles && isValidElement(children)) {\n    const child = Children.only(children);\n\n    return cloneElement(child, {\n      style: { ...mergedStyle, ...child.props.style },\n      className: cn(mergedClassName, child.props.className),\n    });\n  }\n\n  let content = children;\n  if (clone || wrapOnly) {\n    content = Children.map(\n      children,\n      (child) => child && <GridCell clone={clone}>{child}</GridCell>\n    );\n  }\n\n  return (\n    <div {...props} ref={ref} style={mergedStyle} className={mergedClassName}>\n      {content}\n    </div>\n  );\n});\n", "import { createContext, useContext } from \"react\";\n\nimport type { AppSize } from \"./useAppSizeMedia\";\nimport { DEFAULT_APP_SIZE } from \"./useAppSizeMedia\";\n\n/**\n * @internal\n */\nexport const AppSizeContext = createContext<\n  AppSize & { __initialized: boolean }\n>({\n  ...DEFAULT_APP_SIZE,\n  __initialized: false,\n});\n\n/**\n * Gets the current app size.\n *\n * @returns the current AppSize\n */\nexport function useAppSize(): AppSize {\n  const { __initialized, ...context } = useContext(AppSizeContext);\n  if (!__initialized) {\n    throw new Error(\n      \"Unable to get the current `AppSize` from `react-md` because the `AppSizeListener` \" +\n        \"could not be found when using the `useAppSize` hook. To fix this error, either \" +\n        \"initialize the `AppSizeListener` component from `@react-md/utils` or the \" +\n        \"`Configuration` component from `@react-md/layout` near the root of your app.\"\n    );\n  }\n\n  return context;\n}\n", "import { useEffect, useState } from \"react\";\n\nimport type { QuerySize } from \"./constants\";\nimport {\n  DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  DEFAULT_DESKTOP_MIN_WIDTH,\n  DEFAULT_PHONE_MAX_WIDTH,\n  DEFAULT_TABLET_MAX_WIDTH,\n  DEFAULT_TABLET_MIN_WIDTH,\n} from \"./constants\";\nimport { useOrientation } from \"./useOrientation\";\nimport { useWidthMediaQuery } from \"./useWidthMediaQuery\";\n\n/**\n * The current size for your application. This should work both server side and\n * client side, but you will have much better results client side.\n */\nexport interface AppSize {\n  /**\n   * Boolean if currently matching a phone by comparing the max width of the\n   * device.\n   */\n  isPhone: boolean;\n\n  /**\n   * Boolean if currently matching a tablet by comparing the max width of the\n   * device.\n   */\n  isTablet: boolean;\n\n  /**\n   * Boolean if currently matching a desktop screen by comparing the max width\n   * of the device.\n   */\n  isDesktop: boolean;\n\n  /**\n   * Boolean if currently matching a large desktop screen by comparing the max\n   * width of the device.\n   */\n  isLargeDesktop: boolean;\n\n  /**\n   * Boolean if the app is considered to be in landscape mode. This will just\n   * verify that the window width is greater than the window height.\n   *\n   * NOTE: This might not be super accurate on Android devices since the soft\n   * keyboard will change the dimensions of the viewport when it appears. It is\n   * recommended to use the `useOrientation` hook as well if you'd like to get\n   * the current orientation type.\n   */\n  isLandscape: boolean;\n}\n\nexport const DEFAULT_APP_SIZE: AppSize = {\n  isPhone: false,\n  isTablet: false,\n  isDesktop: true,\n  isLargeDesktop: false,\n  isLandscape: true,\n};\n\nexport interface AppSizeOptions {\n  /**\n   * The max width to use for phones. This one is a max width unlike the others\n   * since everything from 0 to this value will be considered a phone.\n   */\n  phoneMaxWidth?: QuerySize;\n\n  /**\n   * The min width for a tablet device.\n   */\n  tabletMinWidth?: QuerySize;\n\n  /**\n   * The max width for a tablet device. This should normally be `1px` less than\n   * the `desktopMinWidth`, but it can be any value if needed. The tablet has a\n   * range of min to max so that you can have a bit more control.\n   */\n  tabletMaxWidth?: QuerySize;\n\n  /**\n   * The min width for a desktop screen.\n   */\n  desktopMinWidth?: QuerySize;\n\n  /**\n   * The min width for a large desktop screen.\n   */\n  desktopLargeMinWidth?: QuerySize;\n\n  /**\n   * An optional default size to use for your app. This is really only helpful\n   * when trying to do server side rendering or initial page render since the\n   * default behavior is to check and update the size once mounted in the DOM.\n   */\n  defaultSize?: AppSize;\n}\n\n/**\n * This hook is used to determine the current application size based on the\n * provided query sizes. When you want to render your app server side, you will\n * need to provide a custom `defaultSize` that implements your logic to\n * determine the type of device requesting a page. Once the app has been\n * rendered in the DOM, this hook will attach event listeners to automatically\n * update the app size when the page is resized.\n *\n * @internal\n */\nexport function useAppSizeMedia({\n  phoneMaxWidth = DEFAULT_PHONE_MAX_WIDTH,\n  tabletMinWidth = DEFAULT_TABLET_MIN_WIDTH,\n  tabletMaxWidth = DEFAULT_TABLET_MAX_WIDTH,\n  desktopMinWidth = DEFAULT_DESKTOP_MIN_WIDTH,\n  desktopLargeMinWidth = DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  defaultSize = DEFAULT_APP_SIZE,\n}: AppSizeOptions = {}): AppSize {\n  /* eslint-disable react-hooks/rules-of-hooks */\n  // disabled since this is conditionally applied for SSR\n  if (typeof window === \"undefined\") {\n    return defaultSize;\n  }\n\n  const matchesDesktop = useWidthMediaQuery({ min: desktopMinWidth });\n  const matchesLargeDesktop = useWidthMediaQuery({ min: desktopLargeMinWidth });\n  const matchesTablet = useWidthMediaQuery({\n    min: tabletMinWidth,\n    max: tabletMaxWidth,\n  });\n  const matchesPhone = useWidthMediaQuery({ max: phoneMaxWidth });\n  const isDesktop = matchesDesktop;\n  const isTablet = !matchesDesktop && matchesTablet;\n  const isPhone = !isTablet && !isDesktop && matchesPhone;\n  const isLandscape = useOrientation().includes(\"landscape\");\n  const isLargeDesktop = matchesLargeDesktop;\n\n  const [appSize, setAppSize] = useState(defaultSize);\n  useEffect(() => {\n    if (\n      appSize.isPhone === isPhone &&\n      appSize.isTablet === isTablet &&\n      appSize.isDesktop === isDesktop &&\n      appSize.isLargeDesktop === isLargeDesktop &&\n      appSize.isLandscape === isLandscape\n    ) {\n      return;\n    }\n\n    // for some reason, it's sometimes possible to fail every single matchMedia\n    // value when you are resizing the browser a lot. this is an \"invalid\" event\n    // so skip it. It normally happens between 760px-768px\n    if (!isPhone && !isTablet && !isDesktop && !isLargeDesktop) {\n      return;\n    }\n\n    setAppSize({ isPhone, isTablet, isDesktop, isLargeDesktop, isLandscape });\n  }, [isPhone, isTablet, isDesktop, isLargeDesktop, isLandscape, appSize]);\n\n  return appSize;\n}\n", "export type QuerySize = number | string;\n\nexport const DEFAULT_DESKTOP_MIN_WIDTH: QuerySize = `${1025 / 16}em`;\nexport const DEFAULT_TABLET_MIN_WIDTH: QuerySize = `${768 / 16}em`;\nexport const DEFAULT_TABLET_MAX_WIDTH: QuerySize = `${1024 / 16}em`;\nexport const DEFAULT_PHONE_MAX_WIDTH: QuerySize = `${767 / 16}em`;\nexport const DEFAULT_DESKTOP_LARGE_MIN_WIDTH: QuerySize = `${1280 / 16}em`;\n", "import { useEffect, useState } from \"react\";\n\n/**\n * An extremely simple \"pollyfill\" for the `window.screen.orientation` just for\n * the `type` value that is required for the `useOrientation` hook.\n */\nexport const getOrientationType = (): OrientationType => {\n  const screenOrientation = window.screen.orientation?.type;\n  if (typeof screenOrientation === \"string\") {\n    return screenOrientation;\n  }\n\n  const { availHeight, availWidth } = window.screen;\n\n  return availHeight > availWidth ? \"portrait-primary\" : \"landscape-primary\";\n};\n\n/**\n * This media query is used to determine the current orientation of the app\n * based on the `window.screen.orientation.type`. This will always be\n * `\"landscape-primary\"` server side unless a default value is provided.\n *\n * @param defaultValue - an optional default value to use. When this is omitted,\n * it will default to `\"landscape-primary\"` unless the `window` is defined. If\n * the `window` is defined, it will immediately check the orientation type on\n * mount.\n * @returns the orientation type value.\n */\nexport function useOrientation(\n  defaultValue?: OrientationType\n): OrientationType {\n  const [value, setValue] = useState<OrientationType>(() => {\n    if (defaultValue) {\n      return defaultValue;\n    }\n\n    if (typeof window !== \"undefined\") {\n      return getOrientationType();\n    }\n\n    return \"landscape-primary\";\n  });\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    const handler = (): void => {\n      setValue(getOrientationType());\n    };\n    window.addEventListener(\"orientationchange\", handler);\n\n    return () => window.removeEventListener(\"orientationchange\", handler);\n  }, []);\n\n  return value;\n}\n", "import { useMemo } from \"react\";\n\nimport type { QuerySize } from \"./constants\";\nimport { useMediaQuery } from \"./useMediaQuery\";\n\n/**\n * This is a small helper that will create a media query block based on the\n * provided width value.\n */\nexport const toWidthPart = (\n  v: QuerySize | undefined,\n  prefix: \"min\" | \"max\"\n): string => {\n  const type = typeof v;\n  if (type === \"undefined\") {\n    return \"\";\n  }\n\n  const value = type === \"number\" ? `${v}px` : v;\n  return `(${prefix}-width: ${value})`;\n};\n\ninterface WidthMediaQuery {\n  min?: QuerySize;\n  max?: QuerySize;\n}\n\ntype WidthMediaQuerys =\n  | { min: QuerySize }\n  | { max: QuerySize }\n  | { min: QuerySize; max: QuerySize };\n\n/**\n * This is a simple hoo that will create a memoized media query string with the\n * provided min anx max values.\n *\n * @param min - An optional min value to use\n * @param max - An optional max value to use\n * @returns a boolean if the current media query is a match.\n */\nexport function useWidthMediaQuery({\n  min,\n  max,\n}: WidthMediaQuery & WidthMediaQuerys): boolean {\n  const query = useMemo(() => {\n    const parts = [toWidthPart(min, \"min\"), toWidthPart(max, \"max\")]\n      .filter(Boolean)\n      .join(\" and \");\n\n    return `screen and ${parts}`;\n  }, [min, max]);\n\n  return useMediaQuery(query);\n}\n", "import { useEffect, useState } from \"react\";\n\n/**\n * A helper hook that is used to create a memoized media query tester for\n * `window.matchMedia`.\n *\n * Note: This is a **client side only** hook as it requires the `window` to\n * attach a resize event listener to.\n *\n * @param query - The media query to use\n * @param defaultValue - The default value for if this media query matches. When\n * this is `undefined`, it will default to `false` unless the `window` is\n * defined and the `checkImmediately` param was not set to `false`. Otherwise,\n * it will check the media query matches on mount and use that value.\n * @param disabled - Boolean if the media query checking should be disabled.\n * @param checkImmediately - Boolean if the media query should be checked\n * immediately on mount. When omitted, it will default to checking when the\n * window is defined.\n * @returns true if the media query is a match.\n */\nexport function useMediaQuery(\n  query: string,\n  defaultValue?: boolean,\n  disabled = false,\n  checkImmediately: boolean = typeof window !== \"undefined\"\n): boolean {\n  const [matches, setMatches] = useState(() => {\n    if (typeof defaultValue !== \"undefined\") {\n      return defaultValue;\n    }\n\n    if (!disabled && checkImmediately && typeof window !== \"undefined\") {\n      return window.matchMedia(query).matches;\n    }\n\n    return false;\n  });\n\n  useEffect(() => {\n    if (typeof window === \"undefined\" || disabled) {\n      return;\n    }\n\n    const mq = window.matchMedia(query);\n    const updater = ({ matches }: MediaQueryListEvent): void =>\n      setMatches(matches);\n\n    mq.addEventListener(\"change\", updater);\n\n    if (mq.matches !== matches) {\n      setMatches(mq.matches);\n    }\n\n    return () => {\n      mq.removeEventListener(\"change\", updater);\n    };\n  }, [disabled, matches, query]);\n\n  return matches;\n}\n", "import type { HTMLAttributes } from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\n\nexport interface GridCSSProperties {\n  /**\n   * The number of rows that a cell should span. If this value is provided, it\n   * will be used instead of the `rowEnd` property. When this is `undefined`, it\n   * will span 1 row as normal.\n   */\n  rowSpan?: number;\n\n  /**\n   * The row that the cell should start at. This is a nice way to be able to\n   * reorder cells within your grid.\n   */\n  rowStart?: number | string;\n\n  /**\n   * The row that the cell should end at. This is a nice way to be able to\n   * reorder cells within your grid but will be ignored if the `rowSpan`\n   * property is provided.\n   */\n  rowEnd?: number | string;\n\n  /**\n   * The number of columns that the cell should span. If this value is provided,\n   * it will be used instead of the `colEnd` property.\n   *\n   * Note: If this value is larger than the number of columns allowed in the\n   * current grid, it will shrink all the other columns.\n   */\n  colSpan?: number;\n\n  /**\n   * The column that the cell should start at. When this is `undefined`, it will\n   * just appear in normal order within the grid.\n   */\n  colStart?: number | string;\n\n  /**\n   * The column that the cell should stop at. When this is `undefined`, it will\n   * just appear in normal order within the grid and span only 1 column. If the\n   * `colSpan` property was provided, this will be ignored.\n   */\n  colEnd?: number | string;\n}\n\nexport interface GridCellProps\n  extends HTMLAttributes<HTMLDivElement>,\n    GridCSSProperties {\n  /**\n   * Boolean if the className should be cloned into the child instead of\n   * wrapping in another div. This will only work if the `children` is a single\n   * ReactElement.\n   */\n  clone?: boolean;\n\n  /**\n   * The number of columns that the cell should span. If this value is provided,\n   * it will be used instead of the `colEnd` property.\n   *\n   * Note: If this value is larger than the number of columns allowed in the\n   * current grid, it will shrink all the other columns.\n   */\n  colSpan?: number;\n\n  /**\n   * Optional Grid CSS Property overries that should be applied on phones only.\n   */\n  phone?: GridCSSProperties;\n\n  /**\n   * Optional Grid CSS Property overries that should be applied on tablets and\n   * above.\n   */\n  tablet?: GridCSSProperties;\n\n  /**\n   * Optional Grid CSS Property overries that should be applied on desktop\n   * screens.\n   */\n  desktop?: GridCSSProperties;\n\n  /**\n   * Optional Grid CSS Property overries that should be applied on large\n   * desktops only.\n   */\n  largeDesktop?: GridCSSProperties;\n}\n\nconst block = bem(\"rmd-grid\");\n\nexport const GridCell = forwardRef<HTMLDivElement, GridCellProps>(\n  function GridCell(\n    {\n      style,\n      className,\n      clone,\n      children,\n      colSpan: propColSpan,\n      colStart: propColStart,\n      colEnd: propColEnd,\n      rowSpan: propRowSpan,\n      rowStart: propRowStart,\n      rowEnd: propRowEnd,\n      phone,\n      tablet,\n      desktop,\n      largeDesktop,\n      ...props\n    },\n    ref\n  ) {\n    const { isPhone, isTablet, isDesktop, isLargeDesktop } = useAppSize();\n\n    let colSpan = propColSpan;\n    let colStart = propColStart;\n    let colEnd = propColEnd;\n    let rowSpan = propRowSpan;\n    let rowStart = propRowStart;\n    let rowEnd = propRowEnd;\n    const media =\n      (isPhone && phone) ||\n      (isTablet && tablet) ||\n      (isLargeDesktop && largeDesktop) ||\n      (isDesktop && desktop);\n\n    if (media) {\n      ({\n        rowSpan = propRowSpan,\n        rowStart = propRowStart,\n        rowEnd = propRowEnd,\n        colSpan = propColSpan,\n        colStart = propColStart,\n        colEnd = propColEnd,\n      } = media);\n    }\n\n    const cellStyle = {\n      gridColumnStart: colStart,\n      gridColumnEnd: colEnd,\n      gridRowStart: rowStart,\n      gridRowEnd: rowSpan ? `span ${rowSpan}` : rowEnd,\n      ...style,\n    };\n    const cellClassName = cn(\n      block(\"cell\", {\n        [`${colSpan}`]: colSpan,\n      }),\n      className\n    );\n\n    if (clone && isValidElement(children)) {\n      const child = Children.only(children);\n      return cloneElement(child, {\n        style: { ...child.props.style, ...cellStyle },\n        className: cn(cellClassName, child.props.className),\n      });\n    }\n\n    return (\n      <div {...props} ref={ref} style={cellStyle} className={cellClassName}>\n        {children}\n      </div>\n    );\n  }\n);\n", "import type { HTMLAttributes, ReactNode } from \"react\";\nimport { Children, forwardRef } from \"react\";\n\nimport { GridListCell } from \"./GridListCell\";\nimport type { GridListSize, UseGridListOptions } from \"./useGridList\";\nimport {\n  DEFAULT_GRID_LIST_MAX_CELL_SIZE,\n  DEFAULT_GRID_LIST_PADDING,\n  GridListSizeProvider,\n  useGridList,\n} from \"./useGridList\";\n\n/**\n * The children render function that will be provided the current grid list size\n * object and should return renderable elements.\n *\n * Note: The first time this is called, the `columns` and `cellWidth` will be\n * the `defaultSize`.  Once the `GridList` has been fully mounted in the DOM, it\n * will begin the sizing calculations and update with the \"real\" values. This\n * doesn't cause any problems if you are only rendering client side, but it\n * might mess up server-side rendering, so it is recommended to update the\n * `defaultSize` when server-side rendering if this can be \"known\" service-side\n * in your app.\n */\nexport type RenderGridListChildren = (size: GridListSize) => ReactNode;\n\nexport interface GridListProps\n  extends HTMLAttributes<HTMLDivElement>,\n    UseGridListOptions {\n  /**\n   * Boolean if the resize observer should stop tracking width changes within\n   * the `GridList`. This should normally stay as `false` since tracking width\n   * changes will allow for dynamic content being added to the list to not mess\n   * up the grid calculation when the user is on an OS that shows scrollbars.\n   */\n  disableHeightObserver?: boolean;\n\n  /**\n   * Boolean if the resize observer should stop tracking width changes within\n   * the `GridList`. This should normally stay as `false` since tracking width\n   * changes will allow for dynamic content being added to the list to not mess\n   * up the grid calculation when the user is on an OS that shows scrollbars.\n   */\n  disableWidthObserver?: boolean;\n\n  /**\n   * The children to display within the grid list. This can either be a callback\n   * function that will provide the current calculated width for each cell that\n   * should return renderable elements or any renderable elements that are sized\n   * with the `--rmd-cell-width` css variable.\n   */\n  children: ReactNode | RenderGridListChildren;\n\n  /**\n   * Boolean if the current cell sizing should automatically be cloned into each\n   * child. This will only work if the `children` is renderable element or a\n   * list of renderable elements that accept the `style` and `className` props.\n   */\n  clone?: boolean;\n\n  /**\n   * Boolean if each child within the `GridList` should be wrapped with the\n   * `GridListCell` component.  This will only work if the `children` is not a\n   * `function`.\n   */\n  wrapOnly?: boolean;\n}\n\nconst isRenderFunction = (\n  children: GridListProps[\"children\"]\n): children is RenderGridListChildren => typeof children === \"function\";\n\n/**\n * The `GridList` component is a different way to render a list of data where\n * the number of columns is dynamic and based on the max-width for each cell.\n * Instead of setting a percentage width to each cell based on the number of\n * columns, this will dynamically add columns to fill up the remaining space and\n * have each cell grow up to a set max-width. A really good use-case for this is\n * displaying a list of images or thumbnails and allowing the user to see a full\n * screen preview once selected/clicked.\n */\nexport const GridList = forwardRef<HTMLDivElement, GridListProps>(\n  function GridList(\n    {\n      style,\n      className,\n      children,\n      clone = false,\n      wrapOnly = false,\n      cellMargin,\n      defaultSize,\n      maxCellSize = DEFAULT_GRID_LIST_MAX_CELL_SIZE,\n      containerPadding = DEFAULT_GRID_LIST_PADDING,\n      disableHeightObserver = false,\n      disableWidthObserver = false,\n      ...props\n    },\n    forwardedRef\n  ) {\n    const [gridListProps, gridSize] = useGridList({\n      ref: forwardedRef,\n      style,\n      className,\n      cellMargin,\n      defaultSize,\n      maxCellSize,\n      containerPadding,\n      disableHeight: disableHeightObserver,\n      disableWidth: disableWidthObserver,\n    });\n\n    let content: ReactNode = null;\n    if (isRenderFunction(children)) {\n      content = children(gridSize);\n    } else if (clone || wrapOnly) {\n      content = Children.map(\n        children,\n        (child) => child && <GridListCell clone={clone}>{child}</GridListCell>\n      );\n    } else {\n      content = children;\n    }\n\n    return (\n      <GridListSizeProvider value={gridSize}>\n        <div {...props} {...gridListProps}>\n          {content}\n        </div>\n      </GridListSizeProvider>\n    );\n  }\n);\n", "import type { HTMLAttributes } from \"react\";\nimport { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\n\nimport { bem } from \"../bem\";\n\nexport interface GridListCellProps extends HTMLAttributes<HTMLDivElement> {\n  /**\n   * Boolean if the className should be cloned into the child instead of\n   * wrapping in another div. This will only work if the `children` is a single\n   * ReactElement.\n   */\n  clone?: boolean;\n\n  /**\n   * Boolean if the cell should be square by also setting the current cell size\n   * to the `height`.\n   */\n  square?: boolean;\n}\n\nconst block = bem(\"rmd-grid-list\");\n\nexport const GridListCell = forwardRef<HTMLDivElement, GridListCellProps>(\n  function GridListCell(\n    { className, children, square = false, clone = false, ...props },\n    ref\n  ) {\n    const cellClassName = cn(block(\"cell\", { square }), className);\n    if (clone && isValidElement(children)) {\n      const child = Children.only(children);\n      return cloneElement(child, {\n        className: cn(cellClassName, child.props.className),\n      });\n    }\n\n    return (\n      <div {...props} ref={ref} className={cellClassName}>\n        {children}\n      </div>\n    );\n  }\n);\n", "import type { RefCallback } from \"react\";\nimport { createContext, useCallback, useContext, useState } from \"react\";\nimport cn from \"classnames\";\n\nimport { useResizeObserver } from \"../sizing/useResizeObserver\";\nimport type { PropsWithRef } from \"../types\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { scrollbarSize } from \"./scrollbarSize\";\n\n/**\n * This is the css variable that is used store the current size of each cell.\n */\nexport const CELL_SIZE_VAR = \"--rmd-cell-size\";\n\n/**\n * This is the css variable that is used store the current margin of each cell.\n */\nexport const CELL_MARGIN_VAR = \"--rmd-cell-margin\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const DEFAULT_GRID_LIST_MAX_CELL_SIZE = 150;\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const DEFAULT_GRID_LIST_PADDING = 16;\n\nexport interface GridListSize {\n  /**\n   * The current number of columns in the `GridList`.\n   */\n  columns: number;\n\n  /**\n   * The current width of each cell within the grid.\n   */\n  cellWidth: number;\n}\n\nconst context = createContext<GridListSize>({\n  columns: -1,\n  cellWidth: -1,\n});\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport const { Provider: GridListSizeProvider } = context;\n\nif (process.env.NODE_ENV !== \"production\") {\n  context.displayName = \"GridListSizeProvider\";\n}\n\n/**\n * Gets the current size of each cell within the `GridList` component. If this\n * is used without a parent `GridList` component, `-1` is returned instead.\n *\n * @remarks \\@since 2.3.0\n */\nexport function useGridListSize(): GridListSize {\n  return useContext(context);\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface UseGridListOptions {\n  /**\n   * An optional style object to merge with the grid custom css properties\n   * object.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * An optional className to merge with the grid list class name\n   */\n  className?: string;\n\n  /**\n   * Boolean if the recalculation of grid sizing should not happen for height\n   * changes.\n   */\n  disableHeight?: boolean;\n\n  /**\n   * Boolean if the recalculation of grid sizing should not happen for width\n   * changes.\n   */\n  disableWidth?: boolean;\n\n  /**\n   * An optional margin to apply to each cell as the `CELL_MARGIN_VAR` css\n   * variable only when it is defined. This has to be a number string with a\n   * `px`, `em`, `rem` or `%` suffix or else the grid will break.\n   */\n  cellMargin?: string;\n\n  /**\n   * The max size that each cell can be.\n   */\n  maxCellSize?: number;\n\n  /**\n   * Since the `GridList` requires being fully rendered in the DOM to be able to\n   * correctly calculate the number of `columns` and `cellWidth`, this _might_\n   * cause problems when server-side rendering when using the children renderer\n   * to create a grid list dynamically based on the number of columns. If the\n   * number of columns and default `cellWidth` can be guessed server-side, you\n   * should provide this prop. Otherwise it will be:\n   * `{ cellSize; maxCellSize, columns: -1 }`\n   */\n  defaultSize?: GridListSize | (() => GridListSize);\n\n  /**\n   * This is _normally_ the amount of padding on the grid list item itself to\n   * subtract from the `offsetWidth` since `padding`, `border`, and vertical\n   * scrollbars will be included.  If you add a border or change the padding or\n   * add borders to this component, you'll need to update the `containerPadding`\n   * to be the new number.\n   */\n  containerPadding?: number;\n}\n\nexport interface ProvidedGridListProps<E extends HTMLElement> {\n  ref: RefCallback<E | null>;\n  style: CSSProperties;\n  className: string;\n}\n\ntype CSSProperties = React.CSSProperties & {\n  [CELL_SIZE_VAR]: string;\n  [CELL_MARGIN_VAR]?: string;\n};\n\nexport type UseGridListReturnValue<E extends HTMLElement> = readonly [\n  ProvidedGridListProps<E>,\n  GridListSize\n];\n\n/**\n * The `useGridList` hook allows you to get all the grid and sizing\n * functionality of the `GridList` component without needing to wrap your\n * children in a `<div>` element.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps] = useGridList({\n *   cellMargin: 16,\n *   maxCellSize: 300,\n *   containerPadding: 4,\n * });\n *\n * return <div {...gridListProps}>{children}</div>;\n * ```\n *\n * Note: You must manually provide the `gridSize` to the `GridListSizeProvider`\n * component that was added in 2.3.0 if you want to use the `useGridSize` hook.\n *\n * Example:\n *\n * ```tsx\n * const [gridListProps, gridSize] = useGridList()\n *\n * return (\n *   <GridListSizeProvider value={gridSize}>\n *     <MyComponent {...gridListProps} />\n *   </GridListSizeProvider>\n * );\n * ```\n *\n * @remarks \\@since 2.3.0\n */\nexport function useGridList<E extends HTMLElement>({\n  ref: propRef,\n  style,\n  className,\n  cellMargin,\n  defaultSize,\n  maxCellSize = DEFAULT_GRID_LIST_MAX_CELL_SIZE,\n  disableHeight = false,\n  disableWidth = false,\n  containerPadding = DEFAULT_GRID_LIST_PADDING,\n}: PropsWithRef<UseGridListOptions, E> = {}): UseGridListReturnValue<E> {\n  const [ref, mergedRef] = useEnsuredRef(propRef);\n  const [gridSize, setGridSize] = useState(\n    defaultSize || { columns: -1, cellWidth: maxCellSize }\n  );\n  const recalculate = useCallback(() => {\n    const target = ref.current;\n    if (!target) {\n      return;\n    }\n\n    // need to use rect instead of offsetWidth since we need decimal precision\n    // for the width since offsetWidth is basically Math.ceil(width). the\n    // calculations for max columns will be off on high-pixel-density monitors\n    // or some zoom levels.\n    let { width } = target.getBoundingClientRect();\n    width -= containerPadding;\n\n    // just need to see if there is a scrollbar visible and subtract that width.\n    // don't need decimal precision here since both values will be rounded\n    if (target.offsetHeight < target.scrollHeight) {\n      width -= scrollbarSize(\"width\");\n    }\n\n    const columns = Math.ceil(width / maxCellSize);\n    setGridSize({ cellWidth: width / columns, columns });\n  }, [containerPadding, maxCellSize, ref]);\n  const [, refHandler] = useResizeObserver(recalculate, {\n    ref: mergedRef,\n    disableHeight,\n    disableWidth,\n  });\n\n  const mergedStyle: CSSProperties = {\n    ...style,\n    [CELL_SIZE_VAR]: `${gridSize.cellWidth}px`,\n  };\n  if (cellMargin) {\n    mergedStyle[CELL_MARGIN_VAR] = cellMargin;\n  }\n\n  return [\n    {\n      ref: refHandler,\n      style: mergedStyle,\n      className: cn(\"rmd-grid-list\", className),\n    },\n    gridSize,\n  ];\n}\n", "var resizeObservers = [];\nexport { resizeObservers };\n", "import { resizeObservers } from '../utils/resizeObservers';\nvar hasActiveObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });\n};\nexport { hasActiveObservations };\n", "import { resizeObservers } from '../utils/resizeObservers';\nvar hasSkippedObservations = function () {\n    return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });\n};\nexport { hasSkippedObservations };\n", "var msg = 'ResizeObserver loop completed with undelivered notifications.';\nvar deliverResizeLoopError = function () {\n    var event;\n    if (typeof ErrorEvent === 'function') {\n        event = new ErrorEvent('error', {\n            message: msg\n        });\n    }\n    else {\n        event = document.createEvent('Event');\n        event.initEvent('error', false, false);\n        event.message = msg;\n    }\n    window.dispatchEvent(event);\n};\nexport { deliverResizeLoopError };\n", "var ResizeObserverBoxOptions;\n(function (ResizeObserverBoxOptions) {\n    ResizeObserverBoxOptions[\"BORDER_BOX\"] = \"border-box\";\n    ResizeObserverBoxOptions[\"CONTENT_BOX\"] = \"content-box\";\n    ResizeObserverBoxOptions[\"DEVICE_PIXEL_CONTENT_BOX\"] = \"device-pixel-content-box\";\n})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));\nexport { ResizeObserverBoxOptions };\n", "export var freeze = function (obj) { return Object.freeze(obj); };\n", "import { freeze } from './utils/freeze';\nvar ResizeObserverSize = (function () {\n    function ResizeObserverSize(inlineSize, blockSize) {\n        this.inlineSize = inlineSize;\n        this.blockSize = blockSize;\n        freeze(this);\n    }\n    return ResizeObserverSize;\n}());\nexport { ResizeObserverSize };\n", "import { freeze } from './utils/freeze';\nvar DOMRectReadOnly = (function () {\n    function DOMRectReadOnly(x, y, width, height) {\n        this.x = x;\n        this.y = y;\n        this.width = width;\n        this.height = height;\n        this.top = this.y;\n        this.left = this.x;\n        this.bottom = this.top + this.height;\n        this.right = this.left + this.width;\n        return freeze(this);\n    }\n    DOMRectReadOnly.prototype.toJSON = function () {\n        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;\n        return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };\n    };\n    DOMRectReadOnly.fromRect = function (rectangle) {\n        return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);\n    };\n    return DOMRectReadOnly;\n}());\nexport { DOMRectReadOnly };\n", "var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };\nvar isHidden = function (target) {\n    if (isSVG(target)) {\n        var _a = target.getBBox(), width = _a.width, height = _a.height;\n        return !width && !height;\n    }\n    var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;\n    return !(offsetWidth || offsetHeight || target.getClientRects().length);\n};\nvar isElement = function (obj) {\n    var _a;\n    if (obj instanceof Element) {\n        return true;\n    }\n    var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;\n    return !!(scope && obj instanceof scope.Element);\n};\nvar isReplacedElement = function (target) {\n    switch (target.tagName) {\n        case 'INPUT':\n            if (target.type !== 'image') {\n                break;\n            }\n        case 'VIDEO':\n        case 'AUDIO':\n        case 'EMBED':\n        case 'OBJECT':\n        case 'CANVAS':\n        case 'IFRAME':\n        case 'IMG':\n            return true;\n    }\n    return false;\n};\nexport { isSVG, isHidden, isElement, isReplacedElement };\n", "export var global = typeof window !== 'undefined' ? window : {};\n", "import { ResizeObserverBoxOptions } from '../ResizeObserverBoxOptions';\nimport { ResizeObserverSize } from '../ResizeObserverSize';\nimport { DOMRectReadOnly } from '../DOMRectReadOnly';\nimport { isSVG, isHidden } from '../utils/element';\nimport { freeze } from '../utils/freeze';\nimport { global } from '../utils/global';\nvar cache = new WeakMap();\nvar scrollRegexp = /auto|scroll/;\nvar verticalRegexp = /^tb|vertical/;\nvar IE = (/msie|trident/i).test(global.navigator && global.navigator.userAgent);\nvar parseDimension = function (pixel) { return parseFloat(pixel || '0'); };\nvar size = function (inlineSize, blockSize, switchSizes) {\n    if (inlineSize === void 0) { inlineSize = 0; }\n    if (blockSize === void 0) { blockSize = 0; }\n    if (switchSizes === void 0) { switchSizes = false; }\n    return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);\n};\nvar zeroBoxes = freeze({\n    devicePixelContentBoxSize: size(),\n    borderBoxSize: size(),\n    contentBoxSize: size(),\n    contentRect: new DOMRectReadOnly(0, 0, 0, 0)\n});\nvar calculateBoxSizes = function (target, forceRecalculation) {\n    if (forceRecalculation === void 0) { forceRecalculation = false; }\n    if (cache.has(target) && !forceRecalculation) {\n        return cache.get(target);\n    }\n    if (isHidden(target)) {\n        cache.set(target, zeroBoxes);\n        return zeroBoxes;\n    }\n    var cs = getComputedStyle(target);\n    var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();\n    var removePadding = !IE && cs.boxSizing === 'border-box';\n    var switchSizes = verticalRegexp.test(cs.writingMode || '');\n    var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');\n    var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');\n    var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);\n    var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);\n    var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);\n    var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);\n    var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);\n    var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);\n    var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);\n    var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);\n    var horizontalPadding = paddingLeft + paddingRight;\n    var verticalPadding = paddingTop + paddingBottom;\n    var horizontalBorderArea = borderLeft + borderRight;\n    var verticalBorderArea = borderTop + borderBottom;\n    var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;\n    var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;\n    var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;\n    var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;\n    var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;\n    var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;\n    var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;\n    var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;\n    var boxes = freeze({\n        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),\n        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),\n        contentBoxSize: size(contentWidth, contentHeight, switchSizes),\n        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)\n    });\n    cache.set(target, boxes);\n    return boxes;\n};\nvar calculateBoxSize = function (target, observedBox, forceRecalculation) {\n    var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;\n    switch (observedBox) {\n        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:\n            return devicePixelContentBoxSize;\n        case ResizeObserverBoxOptions.BORDER_BOX:\n            return borderBoxSize;\n        default:\n            return contentBoxSize;\n    }\n};\nexport { calculateBoxSize, calculateBoxSizes };\n", "import { calculateBoxSizes } from './algorithms/calculateBoxSize';\nimport { freeze } from './utils/freeze';\nvar ResizeObserverEntry = (function () {\n    function ResizeObserverEntry(target) {\n        var boxes = calculateBoxSizes(target);\n        this.target = target;\n        this.contentRect = boxes.contentRect;\n        this.borderBoxSize = freeze([boxes.borderBoxSize]);\n        this.contentBoxSize = freeze([boxes.contentBoxSize]);\n        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);\n    }\n    return ResizeObserverEntry;\n}());\nexport { ResizeObserverEntry };\n", "import { isHidden } from '../utils/element';\nvar calculateDepthForNode = function (node) {\n    if (isHidden(node)) {\n        return Infinity;\n    }\n    var depth = 0;\n    var parent = node.parentNode;\n    while (parent) {\n        depth += 1;\n        parent = parent.parentNode;\n    }\n    return depth;\n};\nexport { calculateDepthForNode };\n", "import { resizeObservers } from '../utils/resizeObservers';\nimport { ResizeObserverEntry } from '../ResizeObserverEntry';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nimport { calculateBoxSize } from './calculateBoxSize';\nvar broadcastActiveObservations = function () {\n    var shallowestDepth = Infinity;\n    var callbacks = [];\n    resizeObservers.forEach(function processObserver(ro) {\n        if (ro.activeTargets.length === 0) {\n            return;\n        }\n        var entries = [];\n        ro.activeTargets.forEach(function processTarget(ot) {\n            var entry = new ResizeObserverEntry(ot.target);\n            var targetDepth = calculateDepthForNode(ot.target);\n            entries.push(entry);\n            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);\n            if (targetDepth < shallowestDepth) {\n                shallowestDepth = targetDepth;\n            }\n        });\n        callbacks.push(function resizeObserverCallback() {\n            ro.callback.call(ro.observer, entries, ro.observer);\n        });\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n    });\n    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {\n        var callback = callbacks_1[_i];\n        callback();\n    }\n    return shallowestDepth;\n};\nexport { broadcastActiveObservations };\n", "import { resizeObservers } from '../utils/resizeObservers';\nimport { calculateDepthForNode } from './calculateDepthForNode';\nvar gatherActiveObservationsAtDepth = function (depth) {\n    resizeObservers.forEach(function processObserver(ro) {\n        ro.activeTargets.splice(0, ro.activeTargets.length);\n        ro.skippedTargets.splice(0, ro.skippedTargets.length);\n        ro.observationTargets.forEach(function processTarget(ot) {\n            if (ot.isActive()) {\n                if (calculateDepthForNode(ot.target) > depth) {\n                    ro.activeTargets.push(ot);\n                }\n                else {\n                    ro.skippedTargets.push(ot);\n                }\n            }\n        });\n    });\n};\nexport { gatherActiveObservationsAtDepth };\n", "import { hasActiveObservations } from '../algorithms/hasActiveObservations';\nimport { hasSkippedObservations } from '../algorithms/hasSkippedObservations';\nimport { deliverResizeLoopError } from '../algorithms/deliverResizeLoopError';\nimport { broadcastActiveObservations } from '../algorithms/broadcastActiveObservations';\nimport { gatherActiveObservationsAtDepth } from '../algorithms/gatherActiveObservationsAtDepth';\nvar process = function () {\n    var depth = 0;\n    gatherActiveObservationsAtDepth(depth);\n    while (hasActiveObservations()) {\n        depth = broadcastActiveObservations();\n        gatherActiveObservationsAtDepth(depth);\n    }\n    if (hasSkippedObservations()) {\n        deliverResizeLoopError();\n    }\n    return depth > 0;\n};\nexport { process };\n", "var trigger;\nvar callbacks = [];\nvar notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };\nvar queueMicroTask = function (callback) {\n    if (!trigger) {\n        var toggle_1 = 0;\n        var el_1 = document.createTextNode('');\n        var config = { characterData: true };\n        new MutationObserver(function () { return notify(); }).observe(el_1, config);\n        trigger = function () { el_1.textContent = \"\".concat(toggle_1 ? toggle_1-- : toggle_1++); };\n    }\n    callbacks.push(callback);\n    trigger();\n};\nexport { queueMicroTask };\n", "import { queueMicroTask } from './queueMicroTask';\nvar queueResizeObserver = function (cb) {\n    queueMicroTask(function ResizeObserver() {\n        requestAnimationFrame(cb);\n    });\n};\nexport { queueResizeObserver };\n", "import { process } from './process';\nimport { global } from './global';\nimport { queueResizeObserver } from './queueResizeObserver';\nvar watching = 0;\nvar isWatching = function () { return !!watching; };\nvar CATCH_PERIOD = 250;\nvar observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };\nvar events = [\n    'resize',\n    'load',\n    'transitionend',\n    'animationend',\n    'animationstart',\n    'animationiteration',\n    'keyup',\n    'keydown',\n    'mouseup',\n    'mousedown',\n    'mouseover',\n    'mouseout',\n    'blur',\n    'focus'\n];\nvar time = function (timeout) {\n    if (timeout === void 0) { timeout = 0; }\n    return Date.now() + timeout;\n};\nvar scheduled = false;\nvar Scheduler = (function () {\n    function Scheduler() {\n        var _this = this;\n        this.stopped = true;\n        this.listener = function () { return _this.schedule(); };\n    }\n    Scheduler.prototype.run = function (timeout) {\n        var _this = this;\n        if (timeout === void 0) { timeout = CATCH_PERIOD; }\n        if (scheduled) {\n            return;\n        }\n        scheduled = true;\n        var until = time(timeout);\n        queueResizeObserver(function () {\n            var elementsHaveResized = false;\n            try {\n                elementsHaveResized = process();\n            }\n            finally {\n                scheduled = false;\n                timeout = until - time();\n                if (!isWatching()) {\n                    return;\n                }\n                if (elementsHaveResized) {\n                    _this.run(1000);\n                }\n                else if (timeout > 0) {\n                    _this.run(timeout);\n                }\n                else {\n                    _this.start();\n                }\n            }\n        });\n    };\n    Scheduler.prototype.schedule = function () {\n        this.stop();\n        this.run();\n    };\n    Scheduler.prototype.observe = function () {\n        var _this = this;\n        var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };\n        document.body ? cb() : global.addEventListener('DOMContentLoaded', cb);\n    };\n    Scheduler.prototype.start = function () {\n        var _this = this;\n        if (this.stopped) {\n            this.stopped = false;\n            this.observer = new MutationObserver(this.listener);\n            this.observe();\n            events.forEach(function (name) { return global.addEventListener(name, _this.listener, true); });\n        }\n    };\n    Scheduler.prototype.stop = function () {\n        var _this = this;\n        if (!this.stopped) {\n            this.observer && this.observer.disconnect();\n            events.forEach(function (name) { return global.removeEventListener(name, _this.listener, true); });\n            this.stopped = true;\n        }\n    };\n    return Scheduler;\n}());\nvar scheduler = new Scheduler();\nvar updateCount = function (n) {\n    !watching && n > 0 && scheduler.start();\n    watching += n;\n    !watching && scheduler.stop();\n};\nexport { scheduler, updateCount };\n", "import { ResizeObserverBoxOptions } from './ResizeObserverBoxOptions';\nimport { calculateBoxSize } from './algorithms/calculateBoxSize';\nimport { isSVG, isReplacedElement } from './utils/element';\nvar skipNotifyOnElement = function (target) {\n    return !isSVG(target)\n        && !isReplacedElement(target)\n        && getComputedStyle(target).display === 'inline';\n};\nvar ResizeObservation = (function () {\n    function ResizeObservation(target, observedBox) {\n        this.target = target;\n        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;\n        this.lastReportedSize = {\n            inlineSize: 0,\n            blockSize: 0\n        };\n    }\n    ResizeObservation.prototype.isActive = function () {\n        var size = calculateBoxSize(this.target, this.observedBox, true);\n        if (skipNotifyOnElement(this.target)) {\n            this.lastReportedSize = size;\n        }\n        if (this.lastReportedSize.inlineSize !== size.inlineSize\n            || this.lastReportedSize.blockSize !== size.blockSize) {\n            return true;\n        }\n        return false;\n    };\n    return ResizeObservation;\n}());\nexport { ResizeObservation };\n", "var ResizeObserverDetail = (function () {\n    function ResizeObserverDetail(resizeObserver, callback) {\n        this.activeTargets = [];\n        this.skippedTargets = [];\n        this.observationTargets = [];\n        this.observer = resizeObserver;\n        this.callback = callback;\n    }\n    return ResizeObserverDetail;\n}());\nexport { ResizeObserverDetail };\n", "import { scheduler, updateCount } from './utils/scheduler';\nimport { ResizeObservation } from './ResizeObservation';\nimport { ResizeObserverDetail } from './ResizeObserverDetail';\nimport { resizeObservers } from './utils/resizeObservers';\nvar observerMap = new WeakMap();\nvar getObservationIndex = function (observationTargets, target) {\n    for (var i = 0; i < observationTargets.length; i += 1) {\n        if (observationTargets[i].target === target) {\n            return i;\n        }\n    }\n    return -1;\n};\nvar ResizeObserverController = (function () {\n    function ResizeObserverController() {\n    }\n    ResizeObserverController.connect = function (resizeObserver, callback) {\n        var detail = new ResizeObserverDetail(resizeObserver, callback);\n        observerMap.set(resizeObserver, detail);\n    };\n    ResizeObserverController.observe = function (resizeObserver, target, options) {\n        var detail = observerMap.get(resizeObserver);\n        var firstObservation = detail.observationTargets.length === 0;\n        if (getObservationIndex(detail.observationTargets, target) < 0) {\n            firstObservation && resizeObservers.push(detail);\n            detail.observationTargets.push(new ResizeObservation(target, options && options.box));\n            updateCount(1);\n            scheduler.schedule();\n        }\n    };\n    ResizeObserverController.unobserve = function (resizeObserver, target) {\n        var detail = observerMap.get(resizeObserver);\n        var index = getObservationIndex(detail.observationTargets, target);\n        var lastObservation = detail.observationTargets.length === 1;\n        if (index >= 0) {\n            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);\n            detail.observationTargets.splice(index, 1);\n            updateCount(-1);\n        }\n    };\n    ResizeObserverController.disconnect = function (resizeObserver) {\n        var _this = this;\n        var detail = observerMap.get(resizeObserver);\n        detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });\n        detail.activeTargets.splice(0, detail.activeTargets.length);\n    };\n    return ResizeObserverController;\n}());\nexport { ResizeObserverController };\n", "import { ResizeObserverController } from './ResizeObserverController';\nimport { isElement } from './utils/element';\nvar ResizeObserver = (function () {\n    function ResizeObserver(callback) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError(\"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.\");\n        }\n        ResizeObserverController.connect(this, callback);\n    }\n    ResizeObserver.prototype.observe = function (target, options) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.observe(this, target, options);\n    };\n    ResizeObserver.prototype.unobserve = function (target) {\n        if (arguments.length === 0) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.\");\n        }\n        if (!isElement(target)) {\n            throw new TypeError(\"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element\");\n        }\n        ResizeObserverController.unobserve(this, target);\n    };\n    ResizeObserver.prototype.disconnect = function () {\n        ResizeObserverController.disconnect(this);\n    };\n    ResizeObserver.toString = function () {\n        return 'function ResizeObserver () { [polyfill code] }';\n    };\n    return ResizeObserver;\n}());\nexport { ResizeObserver };\n", "import type { MutableRefObject, Ref, RefCallback } from \"react\";\nimport { useCallback, useRef } from \"react\";\n\nimport { applyRef } from \"./applyRef\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport type EnsuredRefs<E extends HTMLElement> = readonly [\n  MutableRefObject<E | null>,\n  RefCallback<E | null>\n];\n\n/**\n * This is mostly an internal hook that allows for an optional ref (normally\n * from props or hook options) to be merged with a hook's required `ref`. This\n * will return a MutableRefObject used for DOM manipulation in a custom hook\n * followed by a ref callback function that should be passed to the DOM node\n * that will ensure that both the optional `propRef` and hook ref are updated.\n *\n * @remarks \\@since 2.3.0\n */\nexport function useEnsuredRef<E extends HTMLElement>(\n  propRef?: Ref<E | null>\n): EnsuredRefs<E> {\n  const ref = useRef<E | null>(null);\n  const refHandler = useCallback(\n    (instance: E | null) => {\n      applyRef(instance, propRef);\n      ref.current = instance;\n    },\n    [propRef]\n  );\n\n  return [ref, refHandler];\n}\n", "import type { Ref } from \"react\";\nimport { ResizeObserver } from \"@juggle/resize-observer\";\n\nimport type { EnsuredRefs } from \"../useEnsuredRef\";\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useIsomorphicLayoutEffect } from \"../useIsomorphicLayoutEffect\";\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface UseResizeObserverOptions<E extends HTMLElement> {\n  /**\n   * An optional ref to merge with the returned ref handler function\n   */\n  ref?: Ref<E | null>;\n\n  /**\n   * Boolean if the `onResize` callback should not be triggered if only the\n   * height has changed for the watched element.\n   */\n  disableHeight?: boolean;\n\n  /**\n   * Boolean if the `onResize` callback should not be triggered if only the\n   * width has changed for the watched element.\n   */\n  disableWidth?: boolean;\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface ResizeObserverElementSize {\n  /**\n   * The height for the element that was changed.\n   */\n  height: number;\n\n  /**\n   * The width for the element that was changed.\n   */\n  width: number;\n\n  /**\n   * The scroll height for the element that was changed.\n   */\n  scrollHeight: number;\n\n  /**\n   * The scroll height for the element that was changed.\n   */\n  scrollWidth: number;\n}\n\n/**\n * @remarks \\@since 2.3.0\n */\nexport interface ResizeObserverElementData<E extends HTMLElement = HTMLElement>\n  extends ResizeObserverElementSize {\n  /**\n   * The element that changed due to the resize observer.\n   */\n  element: E;\n}\n\n/**\n * The callback that is triggered each time an element's size change has been\n * observed.\n * @remarks \\@since 2.3.0\n */\nexport type OnResizeObserverChange<E extends HTMLElement = HTMLElement> = (\n  resizeData: ResizeObserverElementData<E>\n) => void;\n\n/**\n * @internal\n */\ninterface ResizeObserverSubscription<E extends HTMLElement> {\n  readonly target: E;\n  readonly handler: OnResizeObserverChange<E>;\n  readonly disableHeight: boolean;\n  readonly disableWidth: boolean;\n  prevSize: ResizeObserverElementSize | undefined;\n}\n\n/**\n * @internal\n */\nfunction isHeightChange(\n  prevSize: ResizeObserverElementSize | undefined,\n  nextSize: ResizeObserverElementSize\n): boolean {\n  return (\n    !prevSize ||\n    prevSize.height !== nextSize.height ||\n    prevSize.scrollHeight !== nextSize.scrollHeight\n  );\n}\n\n/**\n * @internal\n */\nfunction isWidthChange(\n  prevSize: ResizeObserverElementSize | undefined,\n  nextSize: ResizeObserverElementSize\n): boolean {\n  return (\n    !prevSize ||\n    prevSize.width !== nextSize.width ||\n    prevSize.scrollWidth !== nextSize.scrollWidth\n  );\n}\n\n/**\n * Why is there a single shared observer instead of multiple and a\n * \"subscription\" model?\n *\n * Note: Probably a bit of a premature optimization right now...\n *\n * @see https://github.com/WICG/resize-observer/issues/59\n * @internal\n */\nlet sharedObserver: ResizeObserver | undefined;\n\n/**\n *\n * @internal\n */\nconst subscriptions: ResizeObserverSubscription<HTMLElement>[] = [];\n\n/**\n * Lazy initializes the shared resize observer which will loop through all the\n * subscriptions when a resize event is called.\n *\n * @internal\n */\nfunction init(): void {\n  if (sharedObserver || typeof document === \"undefined\") {\n    return;\n  }\n\n  sharedObserver = new ResizeObserver((entries) => {\n    // Note: might need to wait until an requestAnimationFrame has completed to\n    // fix the resize observer loop exceeded error if switching to\n    // `useIsomorphicLayoutEffect` and a shared observer didn't fix that error:\n    // https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n    for (let i = 0; i < entries.length; i += 1) {\n      const entry = entries[i];\n      const currentSubscriptions = subscriptions.filter(\n        ({ target }) => target === entry.target\n      );\n      if (!currentSubscriptions.length) {\n        return;\n      }\n\n      const { height, width } = entry.contentRect;\n      const { scrollHeight, scrollWidth } = entry.target;\n      const nextSize: ResizeObserverElementSize = {\n        height,\n        width,\n        scrollHeight,\n        scrollWidth,\n      };\n\n      for (let j = 0; j < currentSubscriptions.length; j += 1) {\n        const subscription = currentSubscriptions[j];\n        const { handler, prevSize, disableHeight, disableWidth } = subscription;\n        const isNewHeight = isHeightChange(prevSize, nextSize);\n        const isNewWidth = isWidthChange(prevSize, nextSize);\n        if ((isNewHeight && !disableHeight) || (isNewWidth && !disableWidth)) {\n          subscription.prevSize = nextSize;\n          handler({\n            ...nextSize,\n            element: entry.target as typeof subscription.target,\n          });\n        }\n      }\n    }\n  });\n}\n\n/**\n *\n * @internal\n */\nfunction subscribe<E extends HTMLElement>(\n  target: E,\n  onResize: OnResizeObserverChange<E>,\n  disableHeight: boolean,\n  disableWidth: boolean\n): void {\n  const exists = subscriptions.find((sub) => sub.target === target);\n  subscriptions.push({\n    target,\n    handler: onResize as OnResizeObserverChange<HTMLElement>,\n    disableWidth,\n    disableHeight,\n    prevSize: undefined,\n  });\n\n  if (!exists) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver?.observe(target);\n  }\n}\n\n/**\n *\n * @internal\n */\nfunction unsubscribe<E extends HTMLElement>(\n  target: E,\n  onResize: OnResizeObserverChange<E>,\n  disableHeight: boolean,\n  disableWidth: boolean\n): void {\n  const i = subscriptions.findIndex(\n    (sub) =>\n      sub.target === target &&\n      sub.handler === onResize &&\n      sub.disableWidth === disableWidth &&\n      sub.disableHeight === disableHeight\n  );\n  if (i !== -1) {\n    subscriptions.splice(i, 1);\n  }\n\n  const remaining = subscriptions.some((sub) => sub.target === target);\n  if (!remaining) {\n    // I'll silently fail non-initialized observers for now until it becomes an\n    // issue... But how will I ever know?\n    sharedObserver?.unobserve(target);\n  }\n}\n\n/**\n * The new resize observer API that returns a `refHandler` to attach to a DOM\n * node instead of using the weird `target` API.\n *\n * @remarks \\@since 2.3.0\n * @param onResize - The resize handler to call when the element has changed\n * height or width. If you notice performance issues or other oddities, it is\n * recommended to wrap this function in `useCallback`.\n * @param options - Any additional options to use for the resize observer.\n */\nexport function useResizeObserver<E extends HTMLElement>(\n  onResize: OnResizeObserverChange<E>,\n  options: UseResizeObserverOptions<E> = {}\n): EnsuredRefs<E> {\n  const { ref: propRef, disableWidth = false, disableHeight = false } = options;\n  const [ref, refHandler] = useEnsuredRef<E>(propRef);\n\n  useIsomorphicLayoutEffect(() => {\n    const target = ref.current;\n    if ((disableHeight && disableWidth) || !target) {\n      return;\n    }\n\n    init();\n    subscribe(target, onResize, disableHeight, disableWidth);\n    return () => {\n      unsubscribe(target, onResize, disableHeight, disableWidth);\n    };\n  }, [disableHeight, disableWidth, onResize]);\n\n  return [ref, refHandler];\n}\n", "interface Cache {\n  height: number | undefined;\n  width: number | undefined;\n}\n\ntype SizingType = \"height\" | \"width\";\n\nconst cached: Cache = {\n  height: undefined,\n  width: undefined,\n};\n\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\nexport const reset = (): void => {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\nexport function scrollbarSize(\n  type: SizingType = \"width\",\n  forced = false\n): number {\n  /* istanbul ignore if */\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n\n  let value = cached[type];\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n\n  const outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n\n  const inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n\n  const offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\";\n\n  // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n\n  return value;\n}\n", "/**\n * Attempts to find a sizing container based on the provided HTMLElement. By\n * default, the sizing element will just be the provided element unless:\n * - the item has a known role within react-md that can target known classes\n * - the item has a `data-sizing-selector` attribute that is a valid query\n *   selector for the nested item.\n *\n * NOTE: The `data-sizing-selector` will be run from the current element instead\n * of the `document`.\n *\n * @param el - The element to find a sizing container for.\n * @returns the sizing container relative to the provided element, or `null` if\n * none could be found.\n * @throws This error will be thrown if using the `data-query-selector` and the\n * query selector does not return an element on the page.\n */\nexport function findSizingContainer(\n  el: HTMLElement | null\n): HTMLElement | null {\n  if (!el) {\n    return null;\n  }\n\n  if (/(tree|list)item/.test(el.getAttribute(\"role\") || \"\")) {\n    const content = el.querySelector(\n      \".rmd-tree-item__content, .rmd-item-text\"\n    ) as HTMLElement;\n    if (content) {\n      return content;\n    }\n  } else if (el.getAttribute(\"type\") === \"file\") {\n    const label = document.querySelector<HTMLLabelElement>(`[for=\"${el.id}\"]`);\n    if (label) {\n      return label;\n    }\n  }\n\n  const data = el.getAttribute(\"data-sizing-selector\");\n  if (data) {\n    const content = el.querySelector(data) as HTMLElement;\n    if (content) {\n      return content;\n    }\n\n    if (process.env.NODE_ENV !== \"production\") {\n      throw new Error(\n        \"Unable to find a child element using the `data-sizing-selector`\"\n      );\n    }\n  }\n\n  return el;\n}\n", "import { findSizingContainer } from \"./positioning/findSizingContainer\";\n\n/**\n * Attempts to scroll an element into view within another container element if\n * needed.  If either the container or element are `null`, nothing will happen.\n *\n * @param container - The container element that should be scrolled if the child\n * element is not within view.\n * @param element - The element that should be visible within the container\n * element's scroll area.\n */\nexport function scrollIntoView(\n  container: HTMLElement | null,\n  element: HTMLElement | null\n): void {\n  element = findSizingContainer(element);\n  if (!container || !element) {\n    return;\n  }\n\n  let { offsetTop } = element;\n  if (element.offsetParent !== container) {\n    offsetTop -= container.offsetTop;\n  }\n\n  const elementBottom = offsetTop + element.offsetHeight;\n  const containerBottom = container.offsetHeight + container.scrollTop;\n  if (elementBottom > containerBottom) {\n    container.scrollTop = elementBottom - container.offsetHeight;\n  } else if (offsetTop < container.scrollTop) {\n    container.scrollTop = offsetTop;\n  }\n}\n", "import { useCallback, useMemo } from \"react\";\n\nimport { useTempValue } from \"../useTempValue\";\nimport type { FindMatchIndex } from \"./findMatchIndex\";\nimport { findMatchIndex as DEFAULT_FIND_MATCH_INDEX } from \"./findMatchIndex\";\nimport type { BaseSearchOptions } from \"./utils\";\nimport {\n  DEFAULT_GET_ITEM_VALUE,\n  DEFAULT_SEARCH_RESET_TIME,\n  DEFAULT_VALUE_KEY,\n} from \"./utils\";\n\n/**\n * The data that is provided to the `onChange` handler when searching. This will\n * be triggered whenever the user types a letter that causes the current search\n * result to change.\n */\nexport interface SearchData<D = unknown, E extends HTMLElement = HTMLElement> {\n  /**\n   * The item that was matched from the latest search.\n   */\n  readonly item: D;\n\n  /**\n   * The current list of items that were provided to be searched.\n   */\n  readonly items: readonly D[];\n\n  /**\n   * The index in the `items` array that the found item appears at. This is\n   * super useful when extending this hook to be used with\n   * `aria-activedescendant` focus movement or manual focus behavior since the\n   * `items` array should normally be the same indexes as the DOM nodes.\n   */\n  readonly index: number;\n\n  /**\n   * The search value that was used to find this item and trigger the change\n   * event.\n   */\n  readonly query: string;\n\n  /**\n   * The current target for the search keydown event.\n   */\n  readonly target: E;\n}\n\nexport type SearchChangeEvent<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> = (data: SearchData<D, E>) => void;\n\nexport interface BaseKeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseSearchOptions<D> {\n  /**\n   * The list of items that should be searched whenever the user types a letter.\n   */\n  items: readonly D[];\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: SearchChangeEvent<D, E>;\n\n  /**\n   * An optional `onKeyDown` event handler that should be merged with the search\n   * functionality.\n   *\n   * Note: This will be called **before** the search functionality is triggered.\n   */\n  onKeyDown?: React.KeyboardEventHandler<E>;\n\n  /**\n   * The amount of time that a \"search\" value should be kept before resetting.\n   * The default value works for most cases, but it might be nice to configure\n   * it based on your use case.\n   */\n  resetTime?: number;\n\n  /**\n   * The function used to find a match index within the `items` list. You most\n   * likely won't want to change this.\n   */\n  findMatchIndex?: FindMatchIndex;\n}\n\nexport interface KeyboardSearchOptions<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n> extends BaseKeyboardSearchOptions<D, E> {\n  /**\n   * The current index that should be \"focused\" due to a keyboard search. This\n   * should be updated whenever the `onChange` callback is fired.\n   */\n  searchIndex: number;\n}\n\ntype ReturnValue<E extends HTMLElement = HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * Adds the accessibility functionality to search a list of items as the user\n * types to trigger `aria-activedescendant` focus or manual DOM focus events.\n */\nexport function useKeyboardSearch<\n  D = unknown,\n  E extends HTMLElement = HTMLElement\n>({\n  items,\n  onChange,\n  onKeyDown,\n  resetTime = DEFAULT_SEARCH_RESET_TIME,\n  searchIndex,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  findMatchIndex = DEFAULT_FIND_MATCH_INDEX,\n}: KeyboardSearchOptions<D, E>): ReturnValue<E> {\n  const [value, setValue] = useTempValue(\"\", resetTime);\n  const values = useMemo(\n    () => items.map((item) => getItemValue(item, valueKey)),\n    [items, getItemValue, valueKey]\n  );\n\n  const handleKeyDown = useCallback<React.KeyboardEventHandler<E>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const { key, altKey, ctrlKey, metaKey } = event;\n      if (\n        altKey ||\n        ctrlKey ||\n        metaKey ||\n        key.length > 1 ||\n        (!value.current && key === \" \")\n      ) {\n        // might need to change this later if other languages have non-meta keys\n        // that are more than 1 letter\n        return;\n      }\n\n      let nextValue = key;\n      if (value.current !== key) {\n        nextValue = `${value.current}${key}`;\n      }\n      setValue(nextValue);\n\n      const index = findMatchIndex(nextValue, values, searchIndex, true);\n      // don't want to trigger change events if the search didn't match anything\n      // since you normally don't really care about failed matches\n      if (index === searchIndex || index === -1) {\n        return;\n      }\n\n      const data: SearchData<D, E> = {\n        index,\n        item: items[index],\n        items,\n        query: nextValue,\n        target: event.currentTarget,\n      };\n\n      onChange(data);\n    },\n    [\n      searchIndex,\n      findMatchIndex,\n      items,\n      onChange,\n      onKeyDown,\n      setValue,\n      value,\n      values,\n    ]\n  );\n\n  return handleKeyDown;\n}\n", "import type { MutableRefObject } from \"react\";\nimport { useCallback, useRef } from \"react\";\n\ntype CurrentValueRef<T> = MutableRefObject<T>;\ntype SetValue<T> = (nextValue: T) => void;\ntype ResetValue = () => void;\n\ntype ReturnValue<T> = [CurrentValueRef<T>, SetValue<T>, ResetValue];\n\n/**\n * Creates a temporary value that gets reset every `x`ms back to the provided\n * default value. This is useful when doing keyboard searching or other\n * interactions.\n *\n * NOTE: This does not force a re-render when the value changes and instead uses\n * a ref value instead.\n *\n * @typeParam T - the type for the value\n * @param defaultValue - The default value to use. Each time the reset timeout\n * is triggered, this value will be set again.\n * @param resetTime - The amount of time before the value is reset back to the\n * default value\n */\nexport function useTempValue<T>(\n  defaultValue: T,\n  resetTime = 500\n): ReturnValue<T> {\n  const value = useRef(defaultValue);\n  const timeout = useRef<number>();\n  const resetValue = useCallback(() => {\n    window.clearTimeout(timeout.current);\n    value.current = defaultValue;\n  }, [defaultValue]);\n\n  const setValue = useCallback(\n    (nextValue: T) => {\n      value.current = nextValue;\n      window.clearTimeout(timeout.current);\n      timeout.current = window.setTimeout(resetValue, resetTime);\n    },\n    [resetTime, resetValue]\n  );\n\n  return [value, setValue, resetValue];\n}\n", "import type { ReactElement, ReactNode } from \"react\";\nimport { useEffect, useMemo, useRef } from \"react\";\n\nimport {\n  DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  DEFAULT_DESKTOP_MIN_WIDTH,\n  DEFAULT_PHONE_MAX_WIDTH,\n  DEFAULT_TABLET_MAX_WIDTH,\n  DEFAULT_TABLET_MIN_WIDTH,\n} from \"./constants\";\nimport { AppSizeContext } from \"./useAppSize\";\nimport type { AppSize, AppSizeOptions } from \"./useAppSizeMedia\";\nimport { DEFAULT_APP_SIZE, useAppSizeMedia } from \"./useAppSizeMedia\";\n\nexport interface AppSizeListenerProps extends AppSizeOptions {\n  children: ReactNode;\n\n  /**\n   * An change handler for the app size. This will be called each time the app\n   * size changes based on a window resize event and will be provided the next\n   * size and the previous size.\n   */\n  onChange?: (nextSize: AppSize, lastSize: AppSize) => void;\n}\n\n/**\n * This component should be mounted near the top of your app as it will keep\n * track of the current app size based on the provided breakpoint widths.\n */\nexport function AppSizeListener({\n  children,\n  onChange,\n  phoneMaxWidth = DEFAULT_PHONE_MAX_WIDTH,\n  tabletMinWidth = DEFAULT_TABLET_MIN_WIDTH,\n  tabletMaxWidth = DEFAULT_TABLET_MAX_WIDTH,\n  desktopMinWidth = DEFAULT_DESKTOP_MIN_WIDTH,\n  desktopLargeMinWidth = DEFAULT_DESKTOP_LARGE_MIN_WIDTH,\n  defaultSize = DEFAULT_APP_SIZE,\n}: AppSizeListenerProps): ReactElement {\n  const appSize = useAppSizeMedia({\n    phoneMaxWidth,\n    tabletMaxWidth,\n    tabletMinWidth,\n    desktopMinWidth,\n    desktopLargeMinWidth,\n    defaultSize,\n  });\n  const lastValue = useRef(appSize);\n\n  useEffect(() => {\n    // trigger the onChange prop on mount only if there is a difference between\n    // the defaultSize and the mounted size.\n    if (\n      onChange &&\n      (defaultSize.isPhone !== appSize.isPhone ||\n        defaultSize.isTablet !== appSize.isTablet ||\n        defaultSize.isDesktop !== appSize.isDesktop ||\n        defaultSize.isLargeDesktop !== appSize.isLargeDesktop ||\n        defaultSize.isLandscape !== appSize.isLandscape)\n    ) {\n      onChange(appSize, defaultSize);\n    }\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    if (lastValue.current !== appSize) {\n      if (onChange) {\n        onChange(appSize, lastValue.current);\n      }\n\n      lastValue.current = appSize;\n    }\n  });\n\n  const value = useMemo(\n    () => ({\n      ...appSize,\n      __initialized: true,\n    }),\n    [appSize]\n  );\n  return (\n    <AppSizeContext.Provider value={value}>{children}</AppSizeContext.Provider>\n  );\n}\n", "import { useEffect } from \"react\";\n\nimport { delegateEvent } from \"../events/utils\";\nimport { useRefCache } from \"../useRefCache\";\n\nexport interface ResizeListenerOptions {\n  /**\n   * A function to call when the app is resized.\n   */\n  onResize: EventListener;\n\n  /**\n   * Any event listener options to use when attaching the event.\n   */\n  options?: boolean | AddEventListenerOptions;\n\n  /**\n   * Boolean if the resize event handler should be called immediately once the\n   * component is mounted. The default behavior will be to only call the\n   * `onResize` event immediately client side and can never be invoked server\n   * side since it resize on the `window` to dispatch a `UIEvent`.\n   */\n  immediate?: boolean;\n\n  /**\n   * Boolean if the resize observer should be enabled. You can swap this boolean\n   * to `true` or `false` to add/remove the event listeners. The event listeners\n   * will *always* be removed when the parent component is unmounted though.\n   */\n  enabled?: boolean;\n}\n\n/**\n * This is a simple hook that will attach a throttled resize event listener when\n * mounted, and detach when it unmounts.\n *\n * This hook only works for entire app resize events. If you are looking for\n * specific element resize events, check out the `ResizeObserver` component or\n * `useResizeObserver` hook instead.\n */\nexport function useResizeListener({\n  onResize,\n  options,\n  immediate,\n  enabled = true,\n}: ResizeListenerOptions): void {\n  const callback = useRefCache(onResize);\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const eventHandler = delegateEvent(\"resize\", window, true, options);\n    const handler = (event: Event): void => callback.current(event);\n    eventHandler.add(handler);\n\n    if (immediate && typeof window !== \"undefined\") {\n      window.dispatchEvent(new UIEvent(\"resize\"));\n    }\n\n    return () => {\n      eventHandler.remove(handler);\n    };\n    // disabled since useRefCache for callback and don't want immediate to\n    // re-trigger it.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [options, enabled]);\n}\n", "import type { MutableRefObject } from \"react\";\nimport { useEffect } from \"react\";\n\nimport { containsElement } from \"./containsElement\";\n\n/**\n * Gets the HTMLElement or null from a provided RefObject or HTMLElement/null\n * @internal\n */\nexport function getElement<E extends HTMLElement>(\n  element: MutableRefObject<E | null> | E | null\n): E | null {\n  if (!element) {\n    return null;\n  }\n\n  if (typeof (element as MutableRefObject<E | null>).current !== \"undefined\") {\n    return (element as MutableRefObject<E | null>).current;\n  }\n\n  return element as E | null;\n}\n\ntype Contains = typeof containsElement;\n\n/**\n * The on outside click handler that can be used to check for additional logic\n * before triggering some action. This will be provided:\n *\n * - the current element or null\n * - the current click target or null\n * - a nice \"safe\" contains function that handles nulls\n */\nexport type OnOutsideClick<E extends HTMLElement> = (\n  element: E | null,\n  target: HTMLElement | null,\n  contains: Contains\n) => void;\n\n/**\n * @typeParam E - The HTMLElement type of the container element that should not\n * trigger the close behavior if an element inside is clicked.\n */\nexport interface CloseOnOutsideClickOptions<E extends HTMLElement> {\n  /**\n   * Boolean if the behavior is enabled.\n   */\n  enabled: boolean;\n\n  /**\n   * The element that should not trigger the onOutsideClick callback when it or\n   * a child has been clicked.\n   */\n  element: E | null | MutableRefObject<E | null>;\n\n  /**\n   * A callback function when an element outside has been clicked. This is\n   * normally something that closes temporary elements.\n   */\n  onOutsideClick: OnOutsideClick<E>;\n}\n\n/**\n * Triggers a callback function when another element in the page is clicked that\n * is outside of the provided element. This is generally used for closing\n * temporary elements when something else within the page has been clicked.\n *\n * The callback will be provided the current `element` as well as the click\n * target if additional logic should be applied before closing.\n *\n * @typeParam E - The type of element\n */\nexport function useCloseOnOutsideClick<E extends HTMLElement>({\n  enabled,\n  element,\n  onOutsideClick,\n}: CloseOnOutsideClickOptions<E>): void {\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    function handleClick(event: MouseEvent): void {\n      const target = event.target as HTMLElement | null;\n      const el = getElement<E>(element);\n\n      if (!containsElement(el, target)) {\n        onOutsideClick(el, target, containsElement);\n      }\n    }\n\n    window.addEventListener(\"click\", handleClick);\n    return () => {\n      window.removeEventListener(\"click\", handleClick);\n    };\n  }, [enabled, element, onOutsideClick]);\n}\n", "import type { DragEvent, HTMLAttributes } from \"react\";\nimport { useCallback, useState } from \"react\";\n\n/**\n * @remarks \\@since 2.9.0\n * @deprecated \\@since 5.1.3 Use `DropzoneHandlers` instead.\n */\nexport type DropzoneHanders<E extends HTMLElement> = DropzoneHandlers<E>;\n\n/** @remarks \\@since 5.1.3 */\nexport type DropzoneHandlers<E extends HTMLElement> = Pick<\n  HTMLAttributes<E>,\n  \"onDragEnter\" | \"onDragOver\" | \"onDrop\" | \"onDragLeave\"\n>;\n\n/** @remarks \\@since 2.9.0 */\nexport type DropzoneHookReturnValue<E extends HTMLElement> = [\n  boolean,\n  DropzoneHandlers<E>\n];\n\n/**\n * This hook can be used to implement simple drag-and-drop behavior for file\n * uploads or special styles while dragging an element over a part of a page.\n *\n * @example\n * Simple File\n * ```ts\n * const style: CSSProperties = {\n *   border: '1px solid blue',\n * };\n *\n * function Example(): ReactElement {\n *   const { onDrop } = useFileUpload()\n *   const [isOver, handlers] = useDropzone({\n *     onDrop: (event) => {\n *       // normally use the `onDrop` behavior from `useFileUpload` to upload\n *       // files:\n *       // onDrop(event);\n *     }\n *   });\n *\n *   return (\n *     <div {...handlers} style={isOver ? style : {}}>\n *       Drag and drop some files!\n *       {isOver && <UploadSVGIcon />}\n *     </div>\n *   );\n * }\n * ```\n *\n * @see {@link useFileUpload} for a more complex example\n * @param options - The {@link DropzoneHandlers} that can be merged with the\n * default functionality.\n * @returns the {@link DropzoneHookReturnValue}\n * @remarks \\@since 2.9.0\n */\nexport function useDropzone<E extends HTMLElement>(\n  options: DropzoneHandlers<E>\n): DropzoneHookReturnValue<E> {\n  const {\n    onDragEnter: propOnDragEnter,\n    onDragOver: propOnDragOver,\n    onDragLeave: propOnDragLeave,\n    onDrop: propOnDrop,\n  } = options;\n  const [isOver, setOver] = useState(false);\n\n  const onDragOver = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDragOver?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n      setOver(true);\n    },\n    [propOnDragOver]\n  );\n  const onDragEnter = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDragEnter?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n      setOver(true);\n    },\n    [propOnDragEnter]\n  );\n  const onDrop = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDrop?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n      setOver(false);\n    },\n    [propOnDrop]\n  );\n  const onDragLeave = useCallback(\n    (event: DragEvent<E>) => {\n      propOnDragLeave?.(event);\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (\n        !event.target ||\n        event.currentTarget === event.target ||\n        !event.currentTarget.contains(event.target as HTMLElement)\n      ) {\n        setOver(false);\n      }\n    },\n    [propOnDragLeave]\n  );\n\n  return [\n    isOver,\n    {\n      onDragOver,\n      onDragEnter,\n      onDrop,\n      onDragLeave,\n    },\n  ];\n}\n", "import { useEffect } from \"react\";\n\nimport { useRefCache } from \"./useRefCache\";\nimport { useToggle } from \"./useToggle\";\n\ntype Running = boolean;\ntype StartInterval = () => void;\ntype StopInterval = () => void;\ntype ReturnValue = [Running, StartInterval, StopInterval];\n\n/**\n * Simple hook to use an interval with auto setup and teardown. The provided\n * functions will be guaranteed to not change and are memoized.\n *\n * @param callback - The callback function to call\n * @param delay - The time in milliseconds the timer should delay between\n * executions of the callback function\n * @param defaultRunning - Boolean if the interval should be started immediately\n * @returns a list containing a boolean if the interval is running, function to\n * start the interval, and a function to stop the interval.\n */\nexport function useInterval(\n  callback: (stop: () => void) => void,\n  delay: number,\n  defaultRunning = false\n): ReturnValue {\n  const ref = useRefCache(callback);\n\n  const [running, start, stop] = useToggle(defaultRunning);\n\n  useEffect(() => {\n    if (!running) {\n      return;\n    }\n\n    const interval = window.setInterval(() => {\n      ref.current(stop);\n    }, delay);\n    return () => {\n      window.clearInterval(interval);\n    };\n    // disabled since useRefCache for the callback\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [delay, running, stop]);\n\n  return [running, start, stop];\n}\n", "import type { Dispatch, SetStateAction } from \"react\";\nimport { useCallback, useState } from \"react\";\n\nimport { useRefCache } from \"./useRefCache\";\n\ntype Enable = () => void;\ntype Disable = () => void;\ntype Toggle = () => void;\ntype SetToggle = Dispatch<SetStateAction<boolean>>;\n\ntype ReturnValue = [boolean, Enable, Disable, Toggle, SetToggle];\n\n/**\n * This hooks provides an easy way to toggle a boolean flag for React\n * components.  The main use case for this will be toggling the visibility of\n * something. All the provided actions are guaranteed to never change.\n *\n * @param defaultToggled - Boolean if the visibility should be enabled first\n * render.\n * @returns an array containing the toggled state, an enable function, a disable\n * function, a toggle function, and then a manual set toggle function.\n */\nexport function useToggle(\n  defaultToggled: boolean | (() => boolean)\n): ReturnValue {\n  const [toggled, setToggled] = useState(defaultToggled);\n  const previous = useRefCache(toggled);\n\n  const enable = useCallback(() => {\n    if (!previous.current) {\n      setToggled(true);\n    }\n    // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const disable = useCallback(() => {\n    if (previous.current) {\n      setToggled(false);\n    }\n    // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const toggle = useCallback(() => {\n    setToggled((prevVisible) => !prevVisible);\n  }, []);\n\n  return [toggled, enable, disable, toggle, setToggled];\n}\n", "import { useCallback, useEffect, useRef } from \"react\";\n\nimport { useRefCache } from \"./useRefCache\";\nimport { useToggle } from \"./useToggle\";\n\ntype StartTimeout = () => void;\ntype StopTimeout = () => void;\ntype RestartTimeout = () => void;\ntype ReturnValue = [StartTimeout, StopTimeout, RestartTimeout];\n\n/**\n * Simple hook to use an timeout with auto setup and teardown. The provided\n * functions will be guaranteed to not change and are memoized.\n *\n * @param cb - The callback function to call\n * @param delay - The time in milliseconds the timer should delay between\n * executions of the callback function\n * @param defaultStarted - Boolean if the timeout should be started immediately.\n * @returns a list containing a function to start the timeout, a function to\n * stop the timeout, and a function to restart the timeout.\n */\nexport function useTimeout(\n  cb: () => void,\n  delay: number,\n  defaultStarted: boolean | (() => boolean) = false\n): ReturnValue {\n  const cbRef = useRefCache(cb);\n  const delayRef = useRefCache(delay);\n  const timeoutRef = useRef<number>();\n  const [enabled, start, disable] = useToggle(defaultStarted);\n\n  const clearTimeout = useCallback(() => {\n    window.clearTimeout(timeoutRef.current);\n    timeoutRef.current = undefined;\n  }, []);\n\n  /* eslint-disable react-hooks/exhaustive-deps */\n  // these are all guaranteed to not change since using refs or non-updating\n  // callbacks\n  const restart = useCallback(() => {\n    clearTimeout();\n    timeoutRef.current = window.setTimeout(() => {\n      cbRef.current();\n      disable();\n    }, delayRef.current);\n  }, []);\n\n  const stop = useCallback(() => {\n    clearTimeout();\n    disable();\n  }, []);\n\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    timeoutRef.current = window.setTimeout(() => {\n      cbRef.current();\n      disable();\n    }, delay);\n    return () => {\n      clearTimeout();\n    };\n  }, [enabled, delay, disable]);\n\n  return [start, stop, restart];\n}\n", "export const FOCUSABLE_ELEMENTS = [\"BUTTON\", \"TEXTAREA\", \"SELECT\"];\n\nconst BASE_FOCUSABLE_ELEMENTS =\n  'a[href],area[href],input:not([disabled]):not([type=\"hidden\"])';\nconst BASE_FOCUSABLE_QUERY = FOCUSABLE_ELEMENTS.reduce(\n  (queryString, element) => `${queryString},${element}:not([disabled])`,\n  BASE_FOCUSABLE_ELEMENTS\n);\n\n/**\n * A query selector to find elements that are programmatically focusable.\n *\n * Example:\n *\n * ```ts\n * const focusableElements = document.querySelectorAll(PROGRAMATICALLY_FOCUSABLE);\n * // do something with elements\n * ```\n */\nexport const PROGRAMATICALLY_FOCUSABLE = `${BASE_FOCUSABLE_QUERY},[tabindex]`;\n\n/**\n * A query selector to find elements that are focusable only with tab and shift+tab.\n *\n * Example:\n *\n * ```ts\n * const focusableElements = document.querySelectorAll(TAB_FOCUSABLE);\n * // do something with elements\n * ```\n */\nexport const TAB_FOCUSABLE = `${PROGRAMATICALLY_FOCUSABLE}:not([tabindex=\"-1\"])`;\n", "import type { ElementType, HTMLAttributes, ReactElement } from \"react\";\nimport { forwardRef } from \"react\";\n\nimport { useEnsuredRef } from \"../useEnsuredRef\";\nimport { useFocusOnMount } from \"./useFocusOnMount\";\nimport type { FocusFallback } from \"./usePreviousFocus\";\nimport { usePreviousFocus } from \"./usePreviousFocus\";\nimport { useTabFocusWrap } from \"./useTabFocusWrap\";\n\nexport interface FocusContainerOptionsProps {\n  /**\n   * By default, the focus container will try to maintain a cache of the\n   * focusable elements that is updated only when this component re-renders. If\n   * the children are extremely dynamic and focusable elements can be\n   * removed/added without this component updating, you should disable the cache\n   * so that the focusable elements are updated each time the tab key is\n   * pressed. Disabling the cache will be slightly slower for larger focusable\n   * areas, but it might not be too bad.\n   *\n   * NOTE: The only important elements are the *first* and *last* elements in\n   * this list.  So if your children aren't changing the first and last\n   * elements, there's no need to disable the cache.\n   */\n  disableFocusCache?: boolean;\n\n  /**\n   * The default behavior for the focus container is to focus an element once it\n   * is mounted and the `disabled` prop is not enabled. This behavior can be\n   * disabled if this is not wanted for some reason.\n   */\n  disableFocusOnMount?: boolean;\n\n  /**\n   * Boolean if the focus behavior should be disabled. This should really be\n   * used if you are using nested focus containers for temporary material (such\n   * as dialogs or menus).\n   */\n  disableTabFocusWrap?: boolean;\n\n  /**\n   * Boolean if the element that gets focused on mount should try to not scroll\n   * the focused element into view which is the default behavior. This should\n   * normally remain `false`, but it is useful to set to `true` if the\n   * `FocusContainer` is within a transition that appears offscreen.\n   */\n  disableFocusOnMountScroll?: boolean;\n\n  /**\n   * The default behavior for the focus container is to attempt to focus the\n   * element that was focused before the focus container was mounted since it is\n   * generally used for temporary material. If there are cases where this\n   * behavior is not wanted, you can enable this prop.\n   */\n  disableFocusOnUnmount?: boolean;\n\n  /**\n   * This is the element that should be focused by default when the component is\n   * mounted.  This can either be the first or last focusable item or a query\n   * selector string that is run against this component to focus.\n   */\n  defaultFocus?: \"first\" | \"last\" | string;\n\n  /**\n   * When the focus container unmounts, it will attempt to re-focus the element\n   * that was focused before the focus container was mounted unless the\n   * `disableFocusOnUnmount` prop is enabled. There might be cases where\n   * unmounting the focus container causes the page to re-render and the\n   * previous element no longer exists. When this happens keyboard users _might_\n   * have a problem navigating through the page again depending on how the\n   * browser implemented the native tab behavior so this prop allows you to\n   * ensure that a specific element is focused in these cases.\n   *\n   * This can either be a query selector string, a specific HTMLElement, or a\n   * function that finds a specific HTMLElement to focus.\n   */\n  unmountFocusFallback?: FocusFallback;\n}\n\nexport interface FocusContainerProps\n  extends FocusContainerOptionsProps,\n    HTMLAttributes<HTMLElement> {\n  /**\n   * The component to render the focus container as. This should really not be\n   * used as it is more for internal usage. The only base requirements for this\n   * prop is that it must either be a element string (`\"div\"`, `\"span\"`, etc) or\n   * a custom component that has forwarded the ref to the DOM node.\n   */\n  component?: ElementType;\n}\n\n/**\n * The `FocusContainer` is a wrapper for a few of the accessibility hooks to\n * maintain focus within an element.\n */\nexport const FocusContainer = forwardRef<HTMLDivElement, FocusContainerProps>(\n  function FocusContainer(\n    {\n      children,\n      onKeyDown,\n      component: Component = \"div\",\n      defaultFocus = \"first\",\n      disableFocusCache = false,\n      disableFocusOnMount = false,\n      disableFocusOnMountScroll = false,\n      disableFocusOnUnmount = false,\n      disableTabFocusWrap = false,\n      unmountFocusFallback = \"\",\n      ...props\n    },\n    forwardedRef\n  ): ReactElement {\n    const [ref, refHandler] = useEnsuredRef(forwardedRef);\n\n    usePreviousFocus(disableFocusOnUnmount, unmountFocusFallback);\n    useFocusOnMount(\n      ref,\n      defaultFocus,\n      disableFocusOnMountScroll,\n      false,\n      disableFocusOnMount\n    );\n    const handleKeyDown = useTabFocusWrap({\n      disabled: disableTabFocusWrap,\n      disableFocusCache,\n      onKeyDown,\n    });\n\n    return (\n      <Component {...props} onKeyDown={handleKeyDown} ref={refHandler}>\n        {children}\n      </Component>\n    );\n  }\n);\n", "import { useEffect } from \"react\";\n\nimport type { Focus } from \"./focusElementWithin\";\nimport { focusElementWithin } from \"./focusElementWithin\";\nimport type { RefOrInstance } from \"./getInstance\";\nimport { getInstance } from \"./getInstance\";\n\n/**\n * This hook is used to focus an element once a component has mounted. To help\n * with keyboard click events, it will actually wait for an animation frame\n * before attempting to focus as an enter key might click both elements at the\n * same time.\n *\n * This hook will first focus the HTMLElement (if it is focusable) and then\n * focus an element based on the defaultFocus prop.\n *\n * @param refOrInstance - This is either a ref object containing the element to\n * focus or the element itself.\n * @param defaultFocus - The element to focus within the containing element once\n * it has been mounted. This can either be \"first\" or \"last\" to focus the first\n * or last focusable elements or a query selector string to find an element to\n * focus.\n * @param preventScroll - Boolean if the focus events should try to prevent the\n * default scroll-into-view behavior. This is generally recommended to be kept\n * as `false`, but can be useful to enable if the component mounts offscreen\n * during a transition.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included instead of only tab focusable.\n * @param disabled - Boolean if the focus behavior should be disabled.\n */\nexport function useFocusOnMount(\n  refOrInstance: RefOrInstance,\n  defaultFocus: Focus,\n  preventScroll = false,\n  programmatic = false,\n  disabled = false\n): void {\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const frame = window.requestAnimationFrame(() => {\n      const instance = getInstance(refOrInstance);\n      if (!instance) {\n        return;\n      }\n\n      instance.focus({ preventScroll });\n      focusElementWithin(instance, defaultFocus, programmatic, preventScroll);\n    });\n\n    return () => {\n      window.cancelAnimationFrame(frame);\n    };\n  }, [defaultFocus, disabled, refOrInstance, programmatic, preventScroll]);\n}\n", "import { PROGRAMATICALLY_FOCUSABLE, TAB_FOCUSABLE } from \"./constants\";\n\n/**\n * A simple util that will find all the tab focusable elements within a\n * container element.  The container should normally be a specific HTMLElement,\n * but it can also be the entire document if you want to find **all** focusable\n * elements within your page.\n *\n * @param container - The container element/document to find focusable elements\n * within.\n * @param programatic - Boolean if programatically focusable elements should be\n * included instead of only tab focusable.\n * @returns A list of HTMLElements that are focusable within the container.\n */\nexport function getFocusableElements(\n  container: HTMLElement | Document,\n  programatic = false\n): readonly HTMLElement[] {\n  return Array.from(\n    container.querySelectorAll<HTMLElement>(\n      programatic ? PROGRAMATICALLY_FOCUSABLE : TAB_FOCUSABLE\n    )\n  );\n}\n", "import { PROGRAMATICALLY_FOCUSABLE, TAB_FOCUSABLE } from \"./constants\";\n\n/**\n * An element can be tab focused if it is:\n * - an anchor or area with an `href`\n * - a non-disabled `input` element that is not `type=\"hidden\"`\n * - a non-disabled `button`, `textarea`, or `select` element\n * - an element with a `tabIndex >= 0`\n *\n * An element can be noted as \"programmatically focusable only\"  has the above\n * rules, but the `tabIndex` will be set to `-1`.\n *\n * @remarks \\@since 2.8.0\n */\nexport type ElementFocusType = \"tab\" | \"programmatic\";\n\n/**\n * Checks if an element is focusable.\n *\n * @see {@link ElementFocusType}\n * @remarks \\@since 2.8.0\n * @param element - The element to check\n * @param type - The focus type to compare against\n * @returns true if the element is focusable\n */\nexport function isFocusable(\n  element: HTMLElement | Document | Window,\n  type: ElementFocusType = \"programmatic\"\n): element is HTMLElement {\n  return (\n    \"matches\" in element &&\n    element.matches(\n      type === \"programmatic\" ? PROGRAMATICALLY_FOCUSABLE : TAB_FOCUSABLE\n    )\n  );\n}\n", "import { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n\nexport type Focus = \"first\" | \"last\" | string;\n\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optional child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\nexport function focusElementWithin(\n  container: HTMLElement | Document,\n  focus: Focus,\n  programmatic = false,\n  preventScroll = false,\n  elements?: readonly HTMLElement[]\n): void {\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n\n  let el: HTMLElement | null;\n  switch (focus) {\n    case \"first\":\n      [el] = elements;\n      break;\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n    default:\n      el = container.querySelector<HTMLElement>(focus);\n  }\n\n  // just allow any focusable-type element\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n\n  el.focus({ preventScroll });\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container as HTMLElement, el);\n  }\n}\n", "import type { MutableRefObject } from \"react\";\n\n/**\n * A simple type that can be used to get a DOM node either as a ref object from\n * react, an HTMLElement, or null\n */\nexport type RefOrInstance =\n  | HTMLElement\n  | null\n  | MutableRefObject<HTMLElement | null>;\n\n/**\n * Simple private util to get the DOM \"instance\" from either a ref object or an\n * HTMLElement.\n *\n * @param refOrInstance - The ref or instance to get an HTMLElement from\n * @returns The HTMLElement or null.\n * @internal\n */\nexport function getInstance(refOrInstance: RefOrInstance): HTMLElement | null {\n  let instance = null;\n  if (refOrInstance) {\n    if (refOrInstance instanceof HTMLElement) {\n      instance = refOrInstance;\n    } else {\n      instance = refOrInstance.current;\n    }\n  }\n\n  return instance;\n}\n", "import { useEffect, useRef } from \"react\";\n\n/**\n * This can either be a query selector string, a specific HTMLElement, or a\n * function that finds a specific HTMLElement to focus.\n */\nexport type FocusFallback =\n  | string\n  | HTMLElement\n  | (() => HTMLElement | null)\n  | null\n  | undefined;\n\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(\n  disabled: boolean,\n  fallback: FocusFallback = undefined,\n  previousElement: HTMLElement | null = null\n): void {\n  const options = useRef({\n    disabled,\n    fallback,\n  });\n\n  useEffect(() => {\n    options.current = {\n      disabled,\n      fallback,\n    };\n  });\n\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const element = previousElement || (document.activeElement as HTMLElement);\n\n    // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n    const menu = element.closest('[role=\"menu\"]');\n    let menuButton: HTMLElement | null = null;\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-delimitated\n        // string of ids, have to check each one\n        const labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        const query = labelledBy\n          .split(\" \")\n          .map((id) => `#${id}[tabindex]`)\n          .join(\",\");\n\n        menuButton = query ? document.querySelector<HTMLElement>(query) : null;\n      }\n    }\n\n    return () => {\n      const { fallback, disabled } = options.current;\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (\n        menu &&\n        menuButton &&\n        !previousElement &&\n        !fallback &&\n        !document.contains(element) &&\n        document.contains(menuButton)\n      ) {\n        menuButton.focus();\n        return;\n      }\n\n      let el: HTMLElement | null = element;\n      if (!document.contains(el)) {\n        el =\n          previousElement && document.contains(previousElement)\n            ? previousElement\n            : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector<HTMLElement>(fallback);\n            break;\n          case \"function\":\n            el = fallback();\n            break;\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    };\n    // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}\n", "import { useCallback, useRef } from \"react\";\n\nimport { getFocusableElements } from \"./getFocusableElements\";\n\ninterface Options<E extends HTMLElement> {\n  /**\n   * Boolean if the focus wrap behavior should be disabled.\n   */\n  disabled?: boolean;\n\n  /**\n   * Boolean if the list of focusable elements should not be cached after the\n   * first tab key press. This should only be set to `true` if you have a lot of\n   * dynamic content whin your element and the first and last elements change.\n   */\n  disableFocusCache?: boolean;\n\n  /**\n   * An optional keydown event handler to merge with the focus wrap behavior.\n   */\n  onKeyDown?: React.KeyboardEventHandler<E>;\n}\n\n/**\n * Creates an `onKeyDown` event handler to trap keyboard focus within a\n * container element.\n *\n * @typeParam E - The HTMLElement type that has the keydown event listener\n * attached.\n * @param options - All the options for handling tab focus wrapping.\n * @returns The keydown event handler to enforce focus wrapping or the onKeyDown\n * prop if this functionality is disabled.\n */\nexport function useTabFocusWrap<E extends HTMLElement>({\n  disabled = false,\n  disableFocusCache = false,\n  onKeyDown,\n}: Options<E>): React.KeyboardEventHandler<E> | undefined {\n  const focusables = useRef<readonly HTMLElement[]>([]);\n\n  const handleKeyDown = useCallback<React.KeyboardEventHandler<E>>(\n    (event): void => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      if (event.key !== \"Tab\") {\n        return;\n      }\n\n      if (disableFocusCache || !focusables.current.length) {\n        focusables.current = getFocusableElements(event.currentTarget);\n      }\n\n      const elements = focusables.current;\n      const l = elements.length;\n      if (l === 0) {\n        return;\n      }\n\n      if (l === 1) {\n        event.preventDefault();\n        elements[0].focus();\n      } else if (elements[0] === event.target && event.shiftKey) {\n        event.preventDefault();\n        elements[l - 1].focus();\n      } else if (elements[l - 1] === event.target && !event.shiftKey) {\n        event.preventDefault();\n        elements[0].focus();\n      }\n    },\n    [onKeyDown, disableFocusCache]\n  );\n\n  return disabled ? onKeyDown : handleKeyDown;\n}\n", "/**\n * The type of focus that should be triggered from a keypress.\n */\nexport type FocusType = \"increment\" | \"decrement\" | \"first\" | \"last\";\n\n/**\n * A key object that is used to determine what type of behavior to do from a\n * keyboard event.\n */\nexport interface KeyConfig {\n  key: string;\n  type: FocusType;\n  altKey: boolean;\n  ctrlKey: boolean;\n  metaKey: boolean;\n  shiftKey: boolean;\n}\n\n/**\n * The currently supported keyboard movement key combinations that increment or\n * decrement within a list. This was extracted from the w3.org website about\n * wia-aria best practices.\n *\n * @see https://www.w3.org/TR/wai-aria-practices/\n */\nexport enum IncrementMovementKey {\n  ArrowUp = \"ArrowUp\",\n  ArrowDown = \"ArrowDown\",\n  ArrowLeft = \"ArrowLeft\",\n  ArrowRight = \"ArrowRight\",\n  PageDown = \"PageDown\",\n  PageUp = \"PageUp\",\n  ShiftArrowUp = \"Shift+ArrowUp\",\n  ShiftArrowDown = \"Shift+ArrowDown\",\n  ShiftArrowLeft = \"Shift+ArrowLeft\",\n  ShiftArrowRight = \"Shift+ArrowRight\",\n  AltArrowDown = \"Alt+ArrowDown\",\n  AltArrowUp = \"Alt+ArrowUp\",\n  AltArrowLeft = \"Alt+ArrowLeft\",\n  AltArrowRight = \"Alt+ArrowRight\",\n  AltPageDown = \"Alt+PageDown\",\n  AltPageUp = \"Alt+PageUp\",\n  ControlArrowDown = \"Control+ArrowDown\",\n  ControlArrowUp = \"Control+ArrowUp\",\n}\n\n/**\n * The currently supported keyboard movement key combinations that jump to the\n * start or end of a list.  This was extracted from the w3.org website about\n * wai-aria best practices.\n *\n * @see https://www.w3.org/TR/wai-aria-practices/\n */\nexport enum JumpMovementKey {\n  Home = \"Home\",\n  End = \"End\",\n  AltHome = \"Alt+Home\",\n  AltEnd = \"Alt+End\",\n  ControlHome = \"Control+Home\",\n  ControlEnd = \"Control+End\",\n  ControlShiftHome = \"Control+Shift+Home\",\n  ControlShiftEnd = \"Control+Shift+End\",\n}\n\nexport type MovementKey = IncrementMovementKey | JumpMovementKey;\n\nexport interface MovementConfig {\n  /**\n   * Boolean if the keyboard movement should be able to loop around once it has\n   * reached the start or end of all the items.\n   */\n  loopable?: boolean;\n\n  /**\n   * Boolean if the movement should also include printable characters search\n   * movement.\n   */\n  searchable?: boolean;\n\n  /**\n   * The keys that can trigger a move to the next item. If the `loopable` config\n   * is enabled, this will loop to the first item if the last item is currently\n   * \"focused\".\n   */\n  incrementKeys: readonly IncrementMovementKey[];\n\n  /**\n   * The keys that can trigger a move to the previous item. If the `loopable`\n   * config is enabled, this will loop to the last item if the first item is\n   * currently \"focused\".\n   */\n  decrementKeys: readonly IncrementMovementKey[];\n\n  /**\n   * The keys that can trigger a move to the first item.\n   */\n  jumpToFirstKeys: readonly JumpMovementKey[];\n\n  /**\n   * The keys that can trigger a move to the last item.\n   */\n  jumpToLastKeys: readonly JumpMovementKey[];\n}\n", "import type { MovementConfig } from \"./types\";\nimport { IncrementMovementKey, JumpMovementKey } from \"./types\";\n\n/**\n * A keyboard movement configuration preset for handling vertical menu\n * movements.\n */\nexport const VERTICAL_MENU: MovementConfig = {\n  loopable: true,\n  searchable: true,\n  incrementKeys: [IncrementMovementKey.ArrowDown],\n  decrementKeys: [IncrementMovementKey.ArrowUp],\n  jumpToFirstKeys: [JumpMovementKey.Home],\n  jumpToLastKeys: [JumpMovementKey.End],\n};\n\n/**\n * A keyboard movement configuration preset for handling horizontal menu\n * movements.\n */\nexport const HORIZONTAL_MENU: MovementConfig = {\n  ...VERTICAL_MENU,\n  incrementKeys: [IncrementMovementKey.ArrowRight],\n  decrementKeys: [IncrementMovementKey.ArrowLeft],\n};\n\n/**\n * A keyboard movement configuration preset for handling vertical listbox\n * movements.\n */\nexport const VERTICAL_LISTBOX: MovementConfig = {\n  ...VERTICAL_MENU,\n  loopable: false,\n};\n\n/**\n * A keyboard movement configuration preset for handling horizontal listbox\n * movements.\n */\nexport const HORIZONTAL_LISTBOX: MovementConfig = {\n  ...HORIZONTAL_MENU,\n  loopable: false,\n};\n\n/**\n * A keyboard movement configuration preset for handling vertical combobox\n * movements.\n */\nexport const VERTICAL_COMBOBOX: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowDown],\n  decrementKeys: [IncrementMovementKey.ArrowUp],\n  // don't want to be able to jump since home and end should do default behavior\n  // in text field\n  jumpToFirstKeys: [],\n  jumpToLastKeys: [],\n  searchable: false,\n};\n\n/**\n * A keyboard movement configuration preset for handling horizontal combobox\n * movements.\n */\nexport const HORIZONTAL_COMBOBOX: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowRight],\n  decrementKeys: [IncrementMovementKey.ArrowLeft],\n  // don't want to be able to jump since home and end should do default behavior\n  // in text field\n  jumpToFirstKeys: [],\n  jumpToLastKeys: [],\n  searchable: false,\n};\n\nexport const VERTICAL_TREE: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowDown],\n  decrementKeys: [IncrementMovementKey.ArrowUp],\n  jumpToFirstKeys: [JumpMovementKey.Home, JumpMovementKey.ControlShiftHome],\n  jumpToLastKeys: [JumpMovementKey.End, JumpMovementKey.ControlShiftEnd],\n  loopable: true,\n  searchable: true,\n};\n\nexport const HORIZONTAL_TREE: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowRight],\n  decrementKeys: [IncrementMovementKey.ArrowLeft],\n  jumpToFirstKeys: [JumpMovementKey.Home, JumpMovementKey.ControlShiftHome],\n  jumpToLastKeys: [JumpMovementKey.End, JumpMovementKey.ControlShiftEnd],\n  loopable: true,\n  searchable: true,\n};\n\nexport const HORIZONTAL_TABS: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowRight],\n  decrementKeys: [IncrementMovementKey.ArrowLeft],\n  jumpToFirstKeys: [JumpMovementKey.Home],\n  jumpToLastKeys: [JumpMovementKey.End],\n  loopable: true,\n  searchable: false,\n};\n\nexport const VERTICAL_TABS: MovementConfig = {\n  incrementKeys: [IncrementMovementKey.ArrowDown],\n  decrementKeys: [IncrementMovementKey.ArrowUp],\n  jumpToFirstKeys: [JumpMovementKey.Home],\n  jumpToLastKeys: [JumpMovementKey.End],\n  loopable: true,\n  searchable: false,\n};\n", "import type { MutableRefObject } from \"react\";\nimport { useCallback, useMemo } from \"react\";\nimport { loop } from \"../../loop\";\nimport type {\n  BaseKeyboardSearchOptions,\n  SearchData,\n} from \"../../search/useKeyboardSearch\";\nimport { useKeyboardSearch } from \"../../search/useKeyboardSearch\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport type { MovementConfig } from \"./types\";\nimport {\n  getKeyboardConfig,\n  getStringifiedKeyConfig,\n  transformKeys,\n} from \"./utils\";\n\nexport type MovementHandler<E extends HTMLElement> =\n  React.KeyboardEventHandler<E>;\n\n/**\n * A mutable ref object that must be applied to each DOM node within the\n * \"focusable\"/\"searchable\" list of elements so that custom focus behavior can\n * be triggered.\n *\n * @typeParam E - the element type of each item within the focusable list.\n */\nexport type ItemRef<E extends HTMLElement> = MutableRefObject<E | null>;\n\nexport type ItemRefList<E extends HTMLElement = HTMLElement> =\n  readonly ItemRef<E>[];\n\nexport interface BaseKeyboardMovementOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends Omit<BaseKeyboardSearchOptions<D, CE>, \"onChange\">,\n    MovementConfig {\n  /**\n   * Boolean if the event should trigger `event.stopPropagation()` when the\n   * custom keyboard movement is triggered. This should generally be kept as\n   * `false` or `undefined` by default, but enabled when creating more complex\n   * 2-dimensional movement cases such as grids.\n   */\n  stopPropagation?: boolean;\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange?: (data: SearchData<D, CE>, itemRefs: ItemRefList<IE>) => void;\n}\n\n/**\n * The options for custom keyboard movement.\n *\n * @typeParam D - the type of each item within the item list\n * @typeParam CE - the type of the DOM element for the keyboard event handler.\n * @typeParam IE - the type of the DOM element for the keyboard event handler.\n */\nexport interface KeyboardMovementOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The currently focused index within the item list. This will need to be\n   * updated due to the `onChange` callback being called for this hook to work\n   * as it is fully \"controlled\" by a parent hook/component.\n   */\n  focusedIndex: number;\n\n  /**\n   * A required change event handler that will be called whenever a user types a\n   * letter and it causes a new item to be \"found\". This should normally be\n   * something that either updates the `aria-activedescendant` id to the new\n   * found item's id or manually focus the item's DOM node.\n   */\n  onChange: (data: SearchData<D, CE>, itemRefs: ItemRefList<IE>) => void;\n}\n\n/**\n * Returns an ordered list with two items:\n *\n * - itemRefs\n * - onKeyDown event handler\n *\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport type KeyboardMovementProviders<\n  CE extends HTMLElement,\n  IE extends HTMLElement\n> = [\n  /**\n   * A list of mutable ref objects that must be applied to each focusable item\n   * within the list. This list will automatically be generated based on the\n   * number of items provided to the `useKeyboardMovement` hook\n   */\n  ItemRefList<IE>,\n\n  /**\n   * The keydown event handler to apply to a \"container\" element that has custom\n   * keyboard focus.\n   */\n  MovementHandler<CE>\n];\n\n/**\n * This is a low-level hook for providing custom keyboard movement based on key\n * configurations.  This normally shouldn't really be used externally since\n * you'll most likely want to use the \"presets\" of `useFocusMovement` and\n * `useActiveDescendantMovement` that implement the main movement types already\n * for you.\n *\n * The way this works is that it will general a list of mutable item refs that\n * should be applied to each DOM node for the corresponding `item` within the\n * `items` list. This list will change and regenerate itself each time the\n * `items` array changes so it'll always be in-sync with the DOM nodes. This\n * means that if you have some items that **should not be rendered**, they\n * should not be included within the items list. The main reason these item refs\n * are required is so that the `aria-activedescendant` movement can scroll the\n * new \"focused\" element into view if needed while the \"true\" focus movement can\n * trigger a `ref.current.focus()` on the new item as needed.\n *\n * Finally, this will create a keydown event handler that will merge in the\n * optionally provided `onKeyDown` prop and check if the pressed key should\n * trigger a custom keyboard movement event.  If it does, an `onChange` event\n * will be fired with the matching data and allows for custom movement with\n * `target.focus()` or updating the `aria-activedescendant` attribute as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useKeyboardMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  onKeyDown,\n  incrementKeys,\n  decrementKeys,\n  jumpToFirstKeys,\n  jumpToLastKeys,\n  stopPropagation = true,\n  onChange,\n  items,\n  resetTime,\n  findMatchIndex,\n  focusedIndex,\n  loopable = true,\n  searchable = true,\n  valueKey = DEFAULT_VALUE_KEY,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n}: KeyboardMovementOptions<D, CE, IE>): KeyboardMovementProviders<CE, IE> {\n  const keys = useMemo(\n    () => [\n      ...transformKeys(incrementKeys, \"increment\"),\n      ...transformKeys(decrementKeys, \"decrement\"),\n      ...transformKeys(jumpToFirstKeys, \"first\"),\n      ...transformKeys(jumpToLastKeys, \"last\"),\n    ],\n    [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]\n  );\n\n  const itemRefs = useMemo<ItemRefList<IE>>(\n    () => Array.from(items, () => ({ current: null })),\n    [items]\n  );\n\n  const handleSearch = useKeyboardSearch<D, CE>({\n    items,\n    valueKey,\n    getItemValue,\n    onChange(data) {\n      onChange(data, itemRefs);\n    },\n    searchIndex: focusedIndex,\n    resetTime,\n    findMatchIndex,\n  });\n\n  const handleKeyDown = useCallback<MovementHandler<CE>>(\n    (event) => {\n      if (searchable) {\n        handleSearch(event);\n      }\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const target = event.target as HTMLElement;\n      const keyConfig = getKeyboardConfig(event, keys);\n      if (!keyConfig || !target) {\n        return;\n      }\n\n      // implementing custom behavior, so prevent default of scrolling or other\n      // things\n      event.preventDefault();\n      if (stopPropagation) {\n        event.stopPropagation();\n      }\n\n      const { type } = keyConfig;\n\n      const lastIndex = items.length - 1;\n      let index: number;\n      switch (type) {\n        case \"first\":\n          index = 0;\n          break;\n        case \"last\":\n          index = lastIndex;\n          break;\n        default:\n          index = loop({\n            value: focusedIndex,\n            max: lastIndex,\n            increment: type === \"increment\",\n            minmax: !loopable,\n          });\n      }\n\n      if (index === focusedIndex) {\n        return;\n      }\n\n      const data: SearchData<D, CE> = {\n        index,\n        item: items[index],\n        items,\n        query: getStringifiedKeyConfig(keyConfig),\n        target: event.currentTarget,\n      };\n      onChange(data, itemRefs);\n    },\n    [\n      onKeyDown,\n      stopPropagation,\n      focusedIndex,\n      keys,\n      items,\n      handleSearch,\n      loopable,\n      searchable,\n      onChange,\n      itemRefs,\n    ]\n  );\n\n  return [itemRefs, handleKeyDown];\n}\n", "import type { Dispatch, SetStateAction } from \"react\";\nimport { useState } from \"react\";\n\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport type {\n  BaseKeyboardMovementOptions,\n  ItemRefList,\n  MovementHandler,\n} from \"./useKeyboardMovement\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n\nexport type ActiveDescendantId = string;\n\n/**\n *\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport interface ActiveDescendantMovementProviders<\n  CE extends HTMLElement,\n  IE extends HTMLElement\n> {\n  itemRefs: ItemRefList<IE>;\n  onKeyDown: MovementHandler<CE>;\n  activeId: ActiveDescendantId;\n  focusedIndex: number;\n  setFocusedIndex: Dispatch<SetStateAction<number>>;\n}\n\ntype KeyHandler<IE extends HTMLElement = HTMLElement> = (\n  focusedIndex: number,\n  itemRef: IE | null\n) => void;\n\ninterface ActiveDescendantOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The base id that should be used to generate the `aria-activedescendant`\n   * value id. This will be passed into the `getId` option.\n   */\n  baseId: string;\n\n  /**\n   * The function that should generate an id based on the provided `id` and\n   * `index` of the item.\n   */\n  getId?(id: string, index: number): string;\n\n  /**\n   * The default index that should be \"focused\" when the component mounts. This\n   * is set to `-1` by default so that it only gains a new \"focused\" index when\n   * the container element is focused.\n   */\n  defaultFocusedIndex?: (() => number) | number;\n\n  /**\n   * An optional function to call when the enter key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item.\n   */\n  onEnter?: KeyHandler<IE>;\n\n  /**\n   * An optional function to call when the space key has been pressed while the\n   * container element has keyboard focus. This is normally used for triggering\n   * click events for that specific item and will always call\n   * `event.preventDefault()` to prevent the page scrolling behavior.\n   */\n  onSpace?: KeyHandler<IE>;\n}\n\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useActiveDescendantMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  baseId,\n  getId = getItemId,\n  defaultFocusedIndex = -1,\n  items,\n  onChange,\n  getItemValue = DEFAULT_GET_ITEM_VALUE,\n  valueKey = DEFAULT_VALUE_KEY,\n  onKeyDown,\n  onEnter,\n  onSpace,\n  ...options\n}: ActiveDescendantOptions<D, CE, IE>): ActiveDescendantMovementProviders<\n  CE,\n  IE\n> {\n  const [focusedIndex, setFocusedIndex] = useState(defaultFocusedIndex);\n  const activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n\n  const [itemRefs, handleKeyDown] = useKeyboardMovement<D, CE, IE>({\n    ...options,\n    valueKey,\n    getItemValue,\n    focusedIndex,\n    items,\n    onChange(data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      const { index, target } = data;\n      const item = itemRefs[index] && itemRefs[index].current;\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      setFocusedIndex(index);\n    },\n    onKeyDown(event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      const ref =\n        (itemRefs[focusedIndex] && itemRefs[focusedIndex].current) || null;\n      if (onEnter && event.key === \"Enter\") {\n        onEnter(focusedIndex, ref);\n      } else if (onSpace && event.key === \" \") {\n        event.preventDefault();\n        onSpace(focusedIndex, ref);\n      }\n    },\n  });\n\n  return {\n    activeId,\n    itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex,\n    setFocusedIndex,\n  };\n}\n", "import { useEffect, useState } from \"react\";\n\nimport type {\n  BaseKeyboardMovementOptions,\n  KeyboardMovementProviders,\n} from \"./useKeyboardMovement\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\n\ninterface KeyboardFocusOptions<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n> extends BaseKeyboardMovementOptions<D, CE, IE> {\n  /**\n   * The index that should be focused by default.\n   */\n  defaultFocusedIndex?: number;\n}\n\n/**\n * This hook allows for custom keyboard focus movement using DOM focus behavior\n * by actually focusing each DOM node.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have a correct `role` applied as well as the `onKeyDown` event\n * handler provided by this hook. Then, you'll want to applied a\n * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes\n * can be focused as needed. Unfortunately, this means that all the child items\n * **must** either be an HTMLElement or the ref is forwarded down to the\n * HTMLElement.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useFocusMovement<\n  D = unknown,\n  CE extends HTMLElement = HTMLElement,\n  IE extends HTMLElement = HTMLElement\n>({\n  defaultFocusedIndex = -1,\n  onChange,\n  ...options\n}: KeyboardFocusOptions<D, CE, IE>): KeyboardMovementProviders<CE, IE> {\n  const [focusedIndex, setFocusedIndex] = useState(defaultFocusedIndex);\n  const [itemRefs, handleKeyDown] = useKeyboardMovement<D, CE, IE>({\n    ...options,\n    focusedIndex,\n    onChange(data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      const { index } = data;\n      if (index === -1) {\n        return;\n      }\n\n      const item = itemRefs[index] && itemRefs[index].current;\n      if (item) {\n        item.focus();\n      }\n\n      setFocusedIndex(index);\n    },\n  });\n\n  useEffect(() => {\n    if (defaultFocusedIndex === -1) {\n      return;\n    }\n\n    const item =\n      itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;\n    if (item) {\n      item.focus();\n    }\n\n    // only want to trigger on mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  return [itemRefs, handleKeyDown];\n}\n", "import type {\n  CSSProperties,\n  FocusEvent,\n  HTMLAttributes,\n  KeyboardEvent,\n  MouseEvent,\n  ReactNode,\n} from \"react\";\nimport { createRef, forwardRef, useCallback, useMemo, useState } from \"react\";\n\nimport { loop } from \"../../loop\";\nimport type { LabelRequiredForA11y } from \"../../types\";\nimport { tryToSubmitRelatedForm } from \"../tryToSubmitRelatedForm\";\nimport { RadioWidget } from \"./RadioWidget\";\nimport type {\n  RadioWidgetAttributes,\n  RadioItemStyleObject,\n  RadioItem,\n} from \"./types\";\nimport {\n  defaultGetRadioClassName,\n  defaultGetRadioStyle,\n  getRadioItemValue,\n} from \"./utils\";\n\n/**\n * This is a controlled component to render a group of radio buttons when the\n * `<input type=\"radio\">` does not work.\n *\n * @remarks \\@since 2.7.0\n */\nexport interface BaseRadioGroupProps\n  extends Omit<HTMLAttributes<HTMLSpanElement>, \"onChange\"> {\n  /**\n   */\n  id: string;\n\n  /**\n   * The current value for the radio group. This should be the empty string\n   * (`\"\"`) if no values are selected. Otherwise it should match one of the\n   * `values`' value.\n   */\n  value: string;\n\n  /**\n   * A list of values/radio props that should be used to render the radio items.\n   */\n  items: readonly RadioItem[];\n\n  /**\n   * A function that changes the current selection within the radio group.\n   */\n  onChange(nextValue: string): void;\n\n  /**\n   * An optional function to get a `style` object for each rendered radio.\n   */\n  getRadioStyle?(item: RadioItemStyleObject): CSSProperties | undefined;\n\n  /**\n   * An optional function to get a `className` for each rendered radio.\n   */\n  getRadioClassName?(item: RadioItemStyleObject): string | undefined;\n}\n\n/**\n * @remarks \\@since 2.7.0\n */\nexport type RadioGroupProps = LabelRequiredForA11y<BaseRadioGroupProps>;\n\n/**\n * The `RadioGroup` is a low-level component that does not provide any styles\n * and instead only provides the accessibility required for a\n * `role=\"radiogroup\"` and rendering each `role=\"radio\"` item.\n *\n * @remarks \\@since 2.7.0\n */\nexport const RadioGroup = forwardRef<HTMLSpanElement, RadioGroupProps>(\n  function RadioGroup(\n    {\n      id,\n      getRadioStyle = defaultGetRadioStyle,\n      getRadioClassName = defaultGetRadioClassName,\n      items,\n      value: currentValue,\n      onBlur,\n      onFocus,\n      onClick,\n      onChange,\n      onKeyDown,\n      ...props\n    },\n    ref\n  ) {\n    const refs = items.map(() => createRef<HTMLSpanElement>());\n    const [focused, setFocused] = useState(false);\n    const handleBlur = useCallback(\n      (event: FocusEvent<HTMLSpanElement>) => {\n        onBlur?.(event);\n        setFocused(false);\n      },\n      [onBlur]\n    );\n    const handleFocus = useCallback(\n      (event: FocusEvent<HTMLSpanElement>) => {\n        onFocus?.(event);\n        setFocused(true);\n      },\n      [onFocus]\n    );\n    const handleClick = useCallback(\n      (event: MouseEvent<HTMLSpanElement>) => {\n        onClick?.(event);\n\n        /* istanbul ignore next: can't really happen */\n        const radio = (event.target as HTMLElement)?.closest<HTMLSpanElement>(\n          '[role=\"radio\"]'\n        );\n        const index = radio\n          ? refs.findIndex(({ current }) => radio === current)\n          : -1;\n        if (index !== -1) {\n          onChange(getRadioItemValue(items[index]));\n          /* istanbul ignore next: can't really happen */\n          refs[index].current?.focus();\n        }\n      },\n      [onChange, onClick, refs, items]\n    );\n\n    const handleKeyDown = useCallback(\n      (event: KeyboardEvent<HTMLSpanElement>) => {\n        onKeyDown?.(event);\n\n        if (tryToSubmitRelatedForm(event)) {\n          return;\n        }\n\n        if (\n          ![\" \", \"ArrowLeft\", \"ArrowUp\", \"ArrowRight\", \"ArrowDown\"].includes(\n            event.key\n          )\n        ) {\n          return;\n        }\n\n        /* istanbul ignore next: can't really happen */\n        const radio = (event.target as HTMLElement)?.closest<HTMLSpanElement>(\n          '[role=\"radio\"]'\n        );\n        if (!radio) {\n          return;\n        }\n\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.key === \" \") {\n          radio.click();\n          return;\n        }\n\n        const increment =\n          event.key === \"ArrowRight\" || event.key === \"ArrowDown\";\n        const index = refs.findIndex(({ current }) => current === radio);\n        /* istanbul ignore next: can't really happen */\n        if (index !== -1) {\n          const nextIndex = loop({\n            value: index,\n            max: items.length - 1,\n            increment,\n          });\n          refs[nextIndex].current?.focus();\n          onChange(getRadioItemValue(items[nextIndex]));\n        }\n      },\n      [onChange, onKeyDown, refs, items]\n    );\n\n    const focusable = useMemo(\n      () => items.some((value) => getRadioItemValue(value) === currentValue),\n      [currentValue, items]\n    );\n\n    return (\n      <span\n        {...props}\n        id={id}\n        ref={ref}\n        role=\"radiogroup\"\n        onBlur={handleBlur}\n        onFocus={handleFocus}\n        onClick={handleClick}\n        onKeyDown={handleKeyDown}\n        tabIndex={-1}\n      >\n        {items.map((item, i) => {\n          let props: RadioWidgetAttributes | undefined;\n          let value: string;\n          let checked = false;\n          let children: ReactNode;\n          let itemStyle: CSSProperties | undefined;\n          let itemClassName: string | undefined;\n          if (typeof item === \"string\") {\n            value = item;\n            checked = currentValue === value;\n            children = value;\n            itemStyle = getRadioStyle({ index: i, checked, value: item });\n            itemClassName = getRadioClassName({\n              index: i,\n              checked,\n              value: item,\n            });\n          } else {\n            ({ value, children, ...props } = item);\n            checked = currentValue === value;\n            itemStyle = getRadioStyle({ index: i, checked, ...item });\n            itemClassName =\n              getRadioClassName({\n                index: i,\n                checked,\n                ...item,\n              }) || undefined;\n\n            if (typeof children === \"undefined\") {\n              children = value;\n            }\n          }\n\n          return (\n            <RadioWidget\n              {...props}\n              key={value}\n              id={`${id}-${i + 1}`}\n              ref={refs[i]}\n              style={itemStyle}\n              className={itemClassName}\n              checked={checked}\n              tabIndex={checked || (!focused && !focusable) ? 0 : -1}\n            >\n              {children}\n            </RadioWidget>\n          );\n        })}\n      </span>\n    );\n  }\n);\n", "/**\n * Don't really need the full `event` for this, and picking these parts makes it\n * so that both the React keydown listener and native keydown listener can use\n * this function if needed.\n */\ntype KeyboardSubmitEventPartial = Pick<\n  KeyboardEvent,\n  \"key\" | \"preventDefault\" | \"stopPropagation\" | \"currentTarget\"\n>;\n\n/**\n * The default  behavior when pressing the `\"Enter\"` key on a form control\n * (`input`, `textarea`, `select`) is to submit the form that the form control\n * is in. This util will try to polyfill this behavior for custom widgets that\n * use are using a role to act as a form control.\n *\n * The way this works is:\n * - Check if the `event.key` is the `\"Enter\"` key. Do nothing if it is not.\n * - Call `event.preventDefault()` and `event.stopPropagation()` to prevent\n *   other unwanted keyboard behavior\n * - Check the event target to see if it is contained in a `<form>`\n * - Try to find a submit button and click it by:\n *   - First check with `form.querySelector('[type=\"submit\"]')`\n *   - Fallback to `document.querySelector('[type=\"submit\"][form=\"{{FORM_ID}}\"]')`\n *     - submit buttons can be placed outside of the form and link it back using\n *       the `form` attribute pointing to the id of the form\n *\n *\n * The reason the submit button has to be found and clicked is because calling\n * `form.submit()` won't actually fire any attached `form.onsubmit` event\n * handlers. If you click the submit button though, the `form.onsubmit` handlers\n * will be called correctly.\n *\n * @param event - The keyboard event that should attempt to submit the form when\n * the enter key is pressed.\n * @returns `true` if the `event.key` was the `\"Enter\"` key so that other\n * keydown logic can be ignored.\n * @remarks \\@since 2.7.0\n */\nexport function tryToSubmitRelatedForm(\n  event: KeyboardSubmitEventPartial\n): boolean {\n  if (event.key !== \"Enter\") {\n    return false;\n  }\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  /* istanbul ignore next */\n  const form = (event.currentTarget as Element)?.closest?.(\"form\");\n  let submit = form?.querySelector<HTMLButtonElement>('[type=\"submit\"]');\n  if (!submit && form?.id) {\n    submit = document.querySelector<HTMLButtonElement>(\n      `[type=\"submit\"][form=\"${form.id}\"]`\n    );\n  }\n\n  submit?.click();\n  return true;\n}\n", "import { forwardRef } from \"react\";\nimport type { RadioWidgetAttributes } from \"./types\";\n\n/**\n * @remarks \\@since 2.7.0\n */\nexport interface RadioWidgetProps extends RadioWidgetAttributes {\n  /**\n   * An id to use for the item that is required for a11y. This should normally\n   * be handled and provided automatically by the `RadioGroup` component.\n   */\n  id: string;\n\n  /**\n   * Boolean if the radio is currently checked.\n   */\n  checked: boolean;\n\n  /**\n   * The current tab index for the item that should normally be handled\n   * automatically by the `RadioGroup` component. When there are no checked\n   * radio items or the item is checked, this should be `0`. Otherwise this\n   * should be set to `-1` so that it is shown that it can be focused but isn't\n   * included in the tab index flow.\n   */\n  tabIndex: 0 | -1;\n}\n\n/**\n * This component offers no styles and probably shouldn't be used externally\n * since it is just rendered by the `RadioGroup` component.\n *\n * @remarks \\@since 2.7.0\n */\nexport const RadioWidget = forwardRef<HTMLSpanElement, RadioWidgetProps>(\n  function RadioGroupRadio({ checked, children, ...props }, ref) {\n    return (\n      <span {...props} aria-checked={checked} ref={ref} role=\"radio\">\n        {children}\n      </span>\n    );\n  }\n);\n", "import type { CSSProperties } from \"react\";\n\nimport type { RadioItemStyleObject, RadioItem } from \"./types\";\n\n/**\n * Small util to get the value from a {@link RadioItem}.\n *\n * @param value - {@link RadioItem}\n * @returns the current string value of the radio item\n * @remarks \\@since 2.7.0\n */\nexport function getRadioItemValue(value: RadioItem): string {\n  return typeof value === \"string\" ? value : value.value;\n}\n\n/**\n * This util will return the `style` object only if the `RadioItemValue` had a\n * `style` property.\n *\n * @param item - {@link RadioItemStyleObject}\n * @returns an optional style object to provide to the radio.\n * @remarks \\@since 2.7.0\n */\nexport const defaultGetRadioStyle = (\n  item: RadioItemStyleObject\n): CSSProperties | undefined => item.style;\n\n/**\n * This util will return the `className` string only if the `RadioItemValue`\n * had a `className` property.\n *\n * @param item - {@link RadioItemStyleObject}\n * @returns an optional className to provide to the radio\n * @remarks \\@since 2.7.0\n */\nexport const defaultGetRadioClassName = (\n  item: RadioItemStyleObject\n): string | undefined => item.className;\n", "import type { KeyboardEventHandler } from \"react\";\nimport { useCallback } from \"react\";\n\n/**\n * This will conditionally close the dialog when the escape key is pressed.\n *\n * @param onRequestClose - The function to call to close the dialog.\n * @param disabled - Boolean if the escape key functionality should be disabled\n * @param onKeyDown - An optional keydown event handler to also call.\n * @returns A keydown event handler\n */\nexport function useCloseOnEscape<E extends HTMLElement>(\n  onRequestClose: () => void,\n  disabled: boolean,\n  onKeyDown?: KeyboardEventHandler<E>\n): KeyboardEventHandler<E> | undefined {\n  const handleKeyDown = useCallback<KeyboardEventHandler<E>>(\n    (event) => {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      if (event.key === \"Escape\") {\n        onRequestClose();\n      }\n    },\n    [onKeyDown, onRequestClose]\n  );\n\n  return disabled ? onKeyDown : handleKeyDown;\n}\n", "import { useEffect } from \"react\";\n\n/**\n * This is used with the `useScrollLock` effect to determine if the styles were\n * applied by scroll locking or not in the cleanup stage.\n */\nexport const DATA_RMD_NOSCROLL = \"data-rmd-noscroll\";\n\n/**\n * This will enable scroll locking for the provided element. Scroll locking\n * works by fixing the element within the page and hiding overflow for that\n * element.\n *\n * @param element - Either the `<body>` tag or an element within the page to\n * disable scroll for.\n * @internal\n * @remarks \\@since 5.0.0 Renamed from `enable` to `enableScrollLock`.\n */\nexport function enableScrollLock(element: HTMLElement): void {\n  element.style.overflow = \"hidden\";\n  element.setAttribute(DATA_RMD_NOSCROLL, \"\");\n}\n\n/**\n * Attempts to disable the scroll locking behavior for an element. If the\n * element does not have `data-rmd-noscroll`, it will not be modified. This is\n * really just a safety catch to ensure that pre-existing styles aren't removed\n * on accident.\n *\n * If the `data-rmd-noscroll` attribute exists, overflow style and the\n * `data-rmd-noscroll` attribute will be removed.\n *\n * @param element - Either the `<body>` tag or an element within the page to\n * disable scroll locking for.\n * @internal\n * @remarks \\@since 5.0.0 Renamed from `disable` to `disableScrollLock`.\n */\nexport function disableScrollLock(element: HTMLElement): void {\n  if (element.getAttribute(DATA_RMD_NOSCROLL) === null) {\n    return;\n  }\n\n  element.style.overflow = \"\";\n  element.removeAttribute(DATA_RMD_NOSCROLL);\n}\n\n/**\n * A hook that is used to dynamically add scroll locking to an element. By\n * default, this will use the main `<body>` tag for scroll locking, but a query\n * selector string or an HTML element can also be used instead.\n *\n * @param enabled - Boolean if the scroll locking behavior should be enabled\n * @param selectorOrElement - Either a query selector string, HTMLElement, or a\n * function that returns an HTMLElement to apply scroll locking to.\n */\nexport function useScrollLock(\n  enabled: boolean,\n  selectorOrElement?: string | HTMLElement | (() => HTMLElement) | null\n): void {\n  useEffect(() => {\n    if (!enabled || typeof document === \"undefined\") {\n      return;\n    }\n\n    let element: HTMLElement | null = null;\n    if (typeof selectorOrElement === \"string\") {\n      element = document.querySelector<HTMLElement>(selectorOrElement);\n    } else if (typeof selectorOrElement === \"function\") {\n      element = selectorOrElement();\n    } else if (selectorOrElement) {\n      element = selectorOrElement;\n    } else {\n      element = document.body;\n    }\n\n    if (!element || element.getAttribute(DATA_RMD_NOSCROLL) !== null) {\n      return;\n    }\n\n    enableScrollLock(element);\n    return () => {\n      disableScrollLock(element as HTMLElement);\n    };\n  }, [enabled, selectorOrElement]);\n}\n", "import type { CSSProperties, Ref, RefCallback } from \"react\";\nimport { useCallback, useState } from \"react\";\nimport { applyRef } from \"@react-md/utils\";\n\n/** @remarks \\@since 5.0.0 */\nexport interface VerticalDividerHookOptions<E extends HTMLElement> {\n  /**\n   * An optional ref to merge with the returned ref.\n   */\n  ref?: Ref<E>;\n\n  /**\n   * An optional style object to merge with the divider's height style.\n   */\n  style?: CSSProperties;\n\n  /**\n   * The max height for the vertical divider. When this is `<= 0`, the hook will\n   * be disabled.\n   *\n   * When the value is between 0 and 1, it will be used as a multiplier with the\n   * parent element's height. When the value is greater than 1, it will be used\n   * in `Math.min(parentElementHeight, maxHeight)`.\n   */\n  maxHeight: number;\n}\n\n/** @remarks \\@since 5.0.0 */\nexport interface VerticalDividerHeight<E extends HTMLElement> {\n  ref: RefCallback<E>;\n  style: CSSProperties | undefined;\n}\n\n/**\n * This is a small hook that is used to automatically create a vertical divider\n * based on the computed height of its parent element.\n *\n * @param maxHeight - The max height for the vertical divider. When the value is\n * between 0 and 1, it will be used as a percentage. Otherwise the smaller value\n * of parent element height and this will be used.\n * @remarks \\@since 5.0.0 The hook accepts an object instead of using multiple\n * params and uses a generic for the HTMLElement type.\n */\nexport function useVerticalDividerHeight<E extends HTMLElement>({\n  ref,\n  style,\n  maxHeight,\n}: VerticalDividerHookOptions<E>): VerticalDividerHeight<E> {\n  const [height, setHeight] = useState<number | undefined>(undefined);\n  const refCallback = useCallback(\n    (instance: E | null) => {\n      applyRef(instance, ref);\n      if (!instance || !instance.parentElement || maxHeight === 0) {\n        return;\n      }\n\n      const height = instance.parentElement.offsetHeight;\n      if (maxHeight <= 1) {\n        setHeight(height * maxHeight);\n      } else {\n        setHeight(Math.min(height, maxHeight));\n      }\n    },\n    [maxHeight, ref]\n  );\n\n  return {\n    ref: refCallback,\n    style: maxHeight <= 0 ? style : { ...style, height },\n  };\n}\n", "import type { HTMLAttributes } from \"react\";\nimport { forwardRef } from \"react\";\n\nimport { Divider } from \"./Divider\";\nimport { useVerticalDividerHeight } from \"./useVerticalDividerHeight\";\n\nexport interface VerticalDividerProps extends HTMLAttributes<HTMLDivElement> {\n  /** {@inheritDoc VerticalDividerHookOptions.maxHeight} */\n  maxHeight?: number;\n}\n\n/**\n * This component is used to create a vertical divider based on a parent\n * element's height. This is really only needed when the parent element **has no\n * defined height**.  If there is a defined height, this component is not worth\n * much as the height can be computed in css as normal. This really just fixes\n * the issue that the height would be set to `auto` (which computes to 0 most of\n * the time) when it is not set on a parent element.\n */\nexport const VerticalDivider = forwardRef<HTMLDivElement, VerticalDividerProps>(\n  function VerticalDivider({ style, maxHeight = 1, ...props }, ref) {\n    const heightProps = useVerticalDividerHeight({\n      ref,\n      style,\n      maxHeight,\n    });\n\n    return <Divider {...props} {...heightProps} vertical />;\n  }\n);\n"],
  "mappings": "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",
  "names": ["import_react", "import_classnames", "block", "import_react", "import_react", "import_react", "import_react", "import_react", "context", "import_react", "import_react", "import_react", "import_react", "import_react", "context", "import_react", "import_react", "import_react", "noop", "context", "noop", "import_react", "import_react", "import_react", "import_react", "import_classnames", "import_react", "import_react", "import_react", "import_react", "import_react", "context", "import_react", "GridCell", "__rest", "__assign", "cn", "_jsx", "block", "Grid", "__rest", "__assign", "cn", "child", "_jsx", "import_react", "import_react", "import_classnames", "block", "GridListCell", "__rest", "cn", "_jsx", "__assign", "import_react", "import_classnames", "ResizeObserverBoxOptions", "ResizeObserverSize", "DOMRectReadOnly", "ResizeObserverEntry", "callbacks", "process", "ResizeObserver", "Scheduler", "process", "ResizeObservation", "size", "ResizeObserverDetail", "ResizeObserverController", "ResizeObserver", "import_react", "i", "_a", "__assign", "context", "__read", "__assign", "cn", "GridList", "__rest", "__read", "_jsx", "__assign", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "import_react", "__read", "import_react", "fallback", "disabled", "import_react", "FocusContainer", "__rest", "__read", "_jsx", "__assign", "IncrementMovementKey", "JumpMovementKey", "__assign", "import_react", "import_react", "import_react", "import_react", "import_react", "__rest", "_jsx", "__assign", "RadioGroup", "__rest", "__read", "_a", "_b", "_jsx", "__assign", "props", "_createElement", "import_react", "import_react", "block", "Divider", "__rest", "_jsx", "__assign", "cn", "import_react", "__read", "height", "__assign", "import_react", "VerticalDivider", "__rest", "_jsx", "__assign"]
}
