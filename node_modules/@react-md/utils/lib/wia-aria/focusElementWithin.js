"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.focusElementWithin = void 0;
var scrollIntoView_1 = require("../scrollIntoView");
var getFocusableElements_1 = require("./getFocusableElements");
var isFocusable_1 = require("./isFocusable");
/**
 * A function that is used to focus an element within the provided node.  This
 * can either focus the first, last, or a querySelector found element.
 *
 * @param container - Either an HTMLElement or the document to focus an element
 * within.
 * @param focus - Either the "first" or "last" string to focus the first or last
 * focusable element within the container or a query selector string to find a
 * focusable element within the container.
 * @param programmatic - Boolean if programmatically focusable elements should be
 * included as well.
 * @param preventScroll - Boolean if the focus event should not scroll the
 * element into view. This should normally remain `false`, but can be useful if
 * the element gets focused while offscreen during a transition.
 * @param elements - Optional child elements to search
 * @remarks \@since 2.8.0 Supports focusing the container element if it is
 * focusable
 */
function focusElementWithin(container, focus, programmatic, preventScroll, elements) {
    var _a;
    if (programmatic === void 0) { programmatic = false; }
    if (preventScroll === void 0) { preventScroll = false; }
    if (!elements || !elements.length) {
        elements = (0, getFocusableElements_1.getFocusableElements)(container, programmatic);
    }
    var el;
    switch (focus) {
        case "first":
            _a = __read(elements, 1), el = _a[0];
            break;
        case "last":
            el = elements[elements.length - 1];
            break;
        default:
            el = container.querySelector(focus);
    }
    // just allow any focusable-type element
    if (!el && (0, isFocusable_1.isFocusable)(container, "programmatic")) {
        el = container;
    }
    if (!el) {
        throw new Error("Unable to find a focusable element");
    }
    el.focus({ preventScroll: preventScroll });
    if (!preventScroll && container !== document) {
        (0, scrollIntoView_1.scrollIntoView)(container, el);
    }
}
exports.focusElementWithin = focusElementWithin;
//# sourceMappingURL=focusElementWithin.js.map