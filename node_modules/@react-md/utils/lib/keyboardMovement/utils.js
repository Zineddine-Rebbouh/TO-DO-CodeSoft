"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSearchText = exports.getNextFocusableIndex = exports.getLastFocusableIndex = exports.getFirstFocusableIndex = exports.isNotFocusable = exports.focusElement = void 0;
var loop_1 = require("../loop");
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var focusElement = function (element) {
    element.focus();
};
exports.focusElement = focusElement;
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var isNotFocusable = function (element, includeDisabled) {
    if (!element) {
        return true;
    }
    if (includeDisabled) {
        return false;
    }
    return (element.getAttribute("disabled") !== null ||
        element.getAttribute("aria-disabled") === "true");
};
exports.isNotFocusable = isNotFocusable;
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var getFirstFocusableIndex = function (watching, includeDisabled) {
    if (!watching.length) {
        return -1;
    }
    var firstIndex = 0;
    while (firstIndex < watching.length - 1 &&
        (0, exports.isNotFocusable)(watching[firstIndex].element, includeDisabled)) {
        firstIndex += 1;
    }
    if ((0, exports.isNotFocusable)(watching[firstIndex].element, includeDisabled)) {
        return -1;
    }
    return firstIndex;
};
exports.getFirstFocusableIndex = getFirstFocusableIndex;
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var getLastFocusableIndex = function (watching, includeDisabled) {
    if (!watching.length) {
        return -1;
    }
    var lastIndex = watching.length - 1;
    while (lastIndex > 0 &&
        (0, exports.isNotFocusable)(watching[lastIndex].element, includeDisabled)) {
        lastIndex -= 1;
    }
    if ((0, exports.isNotFocusable)(watching[lastIndex].element, includeDisabled)) {
        return -1;
    }
    return lastIndex;
};
exports.getLastFocusableIndex = getLastFocusableIndex;
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var getNextFocusableIndex = function (_a) {
    var loopable = _a.loopable, watching = _a.watching, increment = _a.increment, includeDisabled = _a.includeDisabled, currentFocusIndex = _a.currentFocusIndex;
    var min = (0, exports.getFirstFocusableIndex)(watching, includeDisabled);
    var max = (0, exports.getLastFocusableIndex)(watching, includeDisabled);
    var nextIndex = (0, loop_1.loop)({
        min: min,
        max: max,
        value: currentFocusIndex,
        minmax: !loopable,
        increment: increment,
    });
    while ((0, exports.isNotFocusable)(watching[nextIndex].element, includeDisabled) &&
        (loopable || nextIndex !== (increment ? max : min))) {
        nextIndex = (0, loop_1.loop)({
            min: min,
            max: max,
            value: nextIndex,
            minmax: !loopable,
            increment: increment,
        });
    }
    // Since the `min` and `max` values are "safely" set, I don't need to verify
    // the nextIndex is still focusable
    return nextIndex;
};
exports.getNextFocusableIndex = getNextFocusableIndex;
/**
 * @remarks \@since 5.0.0
 * @internal
 */
function getSearchText(element, searchable) {
    if (!searchable) {
        return "";
    }
    var cloned = element.cloneNode(true);
    cloned
        .querySelectorAll(".rmd-icon--font,[aria-hidden=true],[hidden]")
        .forEach(function (element) {
        var _a;
        (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);
    });
    // Note: It would be good to use `cloned.innerText` (maybe?) at some point,
    // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe
    // this is fine?
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext
    return (cloned.textContent || "").substring(0, 1).toUpperCase();
}
exports.getSearchText = getSearchText;
//# sourceMappingURL=utils.js.map