"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useKeyboardFocus = void 0;
var react_1 = require("react");
var UserInteractionModeListener_1 = require("../mode/UserInteractionModeListener");
var findMatchIndex_1 = require("../search/findMatchIndex");
var movementContext_1 = require("./movementContext");
var utils_1 = require("./utils");
/**
 * @remarks \@since 5.0.0
 * @internal
 */
var noop = function () {
    // do nothing
};
/**
 * @remarks \@since 5.0.0
 */
function useKeyboardFocus(options) {
    if (options === void 0) { options = {}; }
    var _a = options.onFocus, onFocus = _a === void 0 ? noop : _a, _b = options.onKeyDown, onKeyDown = _b === void 0 ? noop : _b, _c = options.onSearch, onSearch = _c === void 0 ? noop : _c, _d = options.onIncrement, onIncrement = _d === void 0 ? noop : _d, _e = options.onDecrement, onDecrement = _e === void 0 ? noop : _e, _f = options.onJumpToFirst, onJumpToFirst = _f === void 0 ? noop : _f, _g = options.onJumpToLast, onJumpToLast = _g === void 0 ? noop : _g, _h = options.onFocusChange, onFocusChange = _h === void 0 ? utils_1.focusElement : _h, getDefaultFocusIndex = options.getDefaultFocusIndex;
    var mode = (0, UserInteractionModeListener_1.useUserInteractionMode)();
    var focusIndex = (0, react_1.useRef)(-1);
    var _j = (0, movementContext_1.useKeyboardFocusContext)(), config = _j.config, loopable = _j.loopable, searchable = _j.searchable, watching = _j.watching, includeDisabled = _j.includeDisabled;
    return {
        focusIndex: focusIndex,
        onFocus: function (event) {
            var _a;
            onFocus(event);
            if (event.isPropagationStopped()) {
                return;
            }
            if (event.target !== event.currentTarget) {
                var i = watching.current.findIndex(function (_a) {
                    var element = _a.element;
                    return element === event.target;
                });
                if (i !== -1) {
                    focusIndex.current = i;
                }
                return;
            }
            var defaultFocusIndex;
            if (getDefaultFocusIndex) {
                defaultFocusIndex = getDefaultFocusIndex(watching.current.map(function (_a) {
                    var element = _a.element;
                    return element;
                }), event.currentTarget);
            }
            else {
                defaultFocusIndex = (0, utils_1.getFirstFocusableIndex)(watching.current, includeDisabled);
            }
            // this makes it so that if you click the container element without
            // clicking any child, it doesn't focus the first element again
            if (defaultFocusIndex === -1 || mode !== "keyboard") {
                return;
            }
            focusIndex.current = defaultFocusIndex;
            var element = (_a = watching.current[focusIndex.current]) === null || _a === void 0 ? void 0 : _a.element;
            element && onFocusChange(element, focusIndex.current);
        },
        onKeyDown: function (event) {
            onKeyDown(event);
            if (event.isPropagationStopped()) {
                return;
            }
            var key = event.key, altKey = event.altKey, ctrlKey = event.ctrlKey, metaKey = event.metaKey, shiftKey = event.shiftKey;
            var _a = config.current, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys;
            var update = function (index) {
                var _a;
                event.preventDefault();
                event.stopPropagation();
                if (focusIndex.current === index) {
                    return;
                }
                focusIndex.current = index;
                var element = (_a = watching.current[index]) === null || _a === void 0 ? void 0 : _a.element;
                element && onFocusChange(element, focusIndex.current);
            };
            if (searchable &&
                key.length === 1 &&
                // can't search with space since it is generally a click event
                key !== " " &&
                !altKey &&
                !ctrlKey &&
                !metaKey &&
                !shiftKey) {
                onSearch({ key: key, event: event });
                if (event.isPropagationStopped()) {
                    return;
                }
                var values = watching.current.map(function (_a) {
                    var content = _a.content, element = _a.element;
                    if ((0, utils_1.isNotFocusable)(element, includeDisabled)) {
                        return "";
                    }
                    return content;
                });
                update((0, findMatchIndex_1.findMatchIndex)(key, values, focusIndex.current));
            }
            else if (jumpToFirstKeys.includes(key)) {
                onJumpToFirst({ key: key, event: event });
                if (event.isPropagationStopped()) {
                    return;
                }
                update((0, utils_1.getFirstFocusableIndex)(watching.current, includeDisabled));
            }
            else if (jumpToLastKeys.includes(key)) {
                onJumpToLast({ key: key, event: event });
                if (event.isPropagationStopped()) {
                    return;
                }
                update((0, utils_1.getLastFocusableIndex)(watching.current, includeDisabled));
            }
            else if (incrementKeys.includes(key)) {
                onIncrement({ key: key, event: event });
                if (event.isPropagationStopped()) {
                    return;
                }
                update((0, utils_1.getNextFocusableIndex)({
                    loopable: loopable,
                    watching: watching.current,
                    increment: true,
                    includeDisabled: includeDisabled,
                    currentFocusIndex: focusIndex.current,
                }));
            }
            else if (decrementKeys.includes(key)) {
                onDecrement({ key: key, event: event });
                if (event.isPropagationStopped()) {
                    return;
                }
                update((0, utils_1.getNextFocusableIndex)({
                    loopable: loopable,
                    watching: watching.current,
                    increment: false,
                    includeDisabled: includeDisabled,
                    currentFocusIndex: focusIndex.current,
                }));
            }
        },
    };
}
exports.useKeyboardFocus = useKeyboardFocus;
//# sourceMappingURL=useKeyboardFocus.js.map