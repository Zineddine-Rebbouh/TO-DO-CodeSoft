"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HoverModeProvider = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var react_1 = require("react");
var useOnUnmount_1 = require("../useOnUnmount");
var constants_1 = require("./constants");
var useHoverModeContext_1 = require("./useHoverModeContext");
/**
 * This component should normally be mounted near the root of your app to enable
 * hover mode for child components. However, it can also be used at other levels
 * if hover mode functionality should not carry over between two different parts
 * of the screen.
 *
 * @example
 * Separating Hover Mode
 * ```tsx
 * export default function Example(): ReactElement {
 *   return (
 *     <>
 *       <HoverModeProvider>
 *         <HeaderActions />
 *       </HoverModeProvider>
 *       <HoverModeProvider>
 *         <MainContent />
 *       </HoverModeProvider>
 *     </>
 *   );
 * }
 * ```
 *
 * @remarks \@since 2.8.0
 */
function HoverModeProvider(_a) {
    var children = _a.children, _b = _a.disabled, disabled = _b === void 0 ? false : _b, _c = _a.defaultVisibleInTime, defaultVisibleInTime = _c === void 0 ? constants_1.DEFAULT_HOVER_MODE_VISIBLE_IN_TIME : _c, _d = _a.deactivateTime, deactivateTime = _d === void 0 ? constants_1.DEFAULT_HOVER_MODE_DEACTIVATION_TIME : _d;
    var _e = __read((0, react_1.useState)(defaultVisibleInTime), 2), visibleInTime = _e[0], setVisibleInTime = _e[1];
    var timeoutRef = (0, react_1.useRef)();
    var enableHoverMode = (0, react_1.useCallback)(function () {
        if (disabled) {
            return;
        }
        window.clearTimeout(timeoutRef.current);
        setVisibleInTime(0);
    }, [disabled]);
    var disableHoverMode = (0, react_1.useCallback)(function () {
        window.clearTimeout(timeoutRef.current);
        setVisibleInTime(defaultVisibleInTime);
    }, [defaultVisibleInTime]);
    var startDisableTimer = (0, react_1.useCallback)(function () {
        window.clearTimeout(timeoutRef.current);
        timeoutRef.current = window.setTimeout(function () {
            setVisibleInTime(defaultVisibleInTime);
        }, deactivateTime);
    }, [defaultVisibleInTime, deactivateTime]);
    (0, react_1.useEffect)(function () {
        if (disabled) {
            window.clearTimeout(timeoutRef.current);
            setVisibleInTime(defaultVisibleInTime);
        }
    }, [disabled, defaultVisibleInTime]);
    (0, useOnUnmount_1.useOnUnmount)(function () {
        window.clearTimeout(timeoutRef.current);
    });
    var context = (0, react_1.useMemo)(function () { return ({
        visibleInTime: visibleInTime,
        enableHoverMode: enableHoverMode,
        disableHoverMode: disableHoverMode,
        startDisableTimer: startDisableTimer,
    }); }, [disableHoverMode, enableHoverMode, startDisableTimer, visibleInTime]);
    return ((0, jsx_runtime_1.jsx)(useHoverModeContext_1.HoverModeContextProvider, __assign({ value: context }, { children: children })));
}
exports.HoverModeProvider = HoverModeProvider;
//# sourceMappingURL=HoverModeProvider.js.map