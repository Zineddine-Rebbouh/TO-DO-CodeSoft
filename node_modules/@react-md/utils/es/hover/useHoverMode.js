var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { useCallback, useEffect, useRef, useState } from "react";
import { useUserInteractionMode } from "../mode";
import { useOnUnmount } from "../useOnUnmount";
import { DEFAULT_HOVER_MODE_EXIT_TIME } from "./constants";
import { useHoverModeContext } from "./useHoverModeContext";
/**
 * This hook is used to add the hover mode functionality to any component.
 *
 * @example
 * Displaying a Color Preview when hovering a Hex Code
 * ```tsx
 * import type { ReactElement } from "react";
 * import { CSSTransition } from "@react-md/transition";
 * import { useHoverMode } from "@react-md/utils";
 *
 * interface Props {
 *   value: string;
 * }
 *
 * export default function Color({ value }: Props): ReactElement {
 *   const { visible, onMouseEnter, onMouseLeave } =
 *     useHoverMode({ exitVisibilityDelay: 0 });
 *
 *   return (
 *     <>
 *       <span
 *         onMouseEnter={onMouseEnter}
 *         onMouseLeave={onMouseLeave}
 *         style={{
 *           // pretend styles
 *         }}
 *       >
 *         {value}
 *       </span>
 *       <CSSTransition
 *         transitionIn={visible}
 *         classNames="opacity-change"
 *         timeout={150}
 *         temporary
 *       >
 *         <span
 *           style={{
 *             backgroundColor: value,
 *             // other styles
 *           }}
 *         />
 *      </CSSTransition>
 *     </>
 *   );
 * }
 * ```
 *
 * @example
 * Sticky Usage with a Fixed Dialog
 * ```tsx
 * const {
 *   stuck,
 *   active,
 *   visible,
 *   setVisible,
 *   handlers,
 *   hoverHandlers,
 * } = useHoverMode();
 * const buttonRef = useRef<HTMLButtonElement>(null);
 *
 * return (
 *   <>
 *     <Button {...handlers} ref={buttonRef}>
 *       Click Me
 *     </Button>
 *     <FixedDialog
 *       {...hoverHandlers}
 *       aria-labelledby="dialog-title-id"
 *       id="dialog-id"
 *       visible={visible}
 *       onRequestClose={() => setVisible(false)}
 *       fixedTo={buttonRef}
 *       anchor={BELOW_CENTER_ANCHOR}
 *       options={{ preventOverlap: true }}
 *       // this allows the close on outside click"" behavior" to work
 *       overlay={!stuck && active ? false : undefined}
 *       disableScrollLock={active}
 *     >
 *       <YourDialogContent />
 *    </FixedDialog>
 *   </>
 * );
 * ```
 *
 * @remarks \@since 2.8.0
 * @remarks \@since 5.0.0 This hook no longer returns `handlers` or
 * `stickyHandlers` and does not hide when an element on the page is clicked.
 * @param options - An optional object of options to use. See
 * {@link HoverModeOptions} for more details.
 * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}
 */
export function useHoverMode(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.disabled, disabled = _c === void 0 ? false : _c, _d = _b.defaultVisible, defaultVisible = _d === void 0 ? false : _d, _e = _b.exitVisibilityDelay, exitVisibilityDelay = _e === void 0 ? DEFAULT_HOVER_MODE_EXIT_TIME : _e;
    var mode = useUserInteractionMode();
    var isTouch = mode === "touch";
    var _f = __read(useState(defaultVisible), 2), visible = _f[0], setVisible = _f[1];
    var _g = __read(useState(false), 2), stuck = _g[0], setStuck = _g[1];
    var timeoutRef = useRef();
    var _h = useHoverModeContext(), visibleInTime = _h.visibleInTime, enableHoverMode = _h.enableHoverMode, disableHoverMode = _h.disableHoverMode, startDisableTimer = _h.startDisableTimer;
    var active = visibleInTime === 0;
    useEffect(function () {
        if (!visible) {
            setStuck(false);
        }
    }, [visible]);
    useOnUnmount(function () {
        window.clearTimeout(timeoutRef.current);
    });
    var clearHoverTimeout = useCallback(function () {
        window.clearTimeout(timeoutRef.current);
    }, []);
    var onMouseEnter = useCallback(function (event) {
        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
            return;
        }
        clearHoverTimeout();
        if (visibleInTime === 0) {
            enableHoverMode();
            setVisible(true);
            return;
        }
        timeoutRef.current = window.setTimeout(function () {
            enableHoverMode();
            setVisible(true);
        }, visibleInTime);
    }, [
        clearHoverTimeout,
        disabled,
        enableHoverMode,
        isTouch,
        stuck,
        visibleInTime,
    ]);
    var onMouseLeave = useCallback(function (event) {
        if (stuck || disabled || isTouch || event.isPropagationStopped()) {
            return;
        }
        startDisableTimer();
        clearHoverTimeout();
        if (exitVisibilityDelay === 0) {
            setVisible(false);
            return;
        }
        timeoutRef.current = window.setTimeout(function () {
            setVisible(false);
        }, exitVisibilityDelay);
    }, [
        clearHoverTimeout,
        disabled,
        exitVisibilityDelay,
        isTouch,
        startDisableTimer,
        stuck,
    ]);
    var onClick = useCallback(function (event) {
        if (event.isPropagationStopped()) {
            return;
        }
        // If the hover mode functionality is disabled, just allow this to behave
        // like a toggle visibility handler.
        if (!stuck && !disabled) {
            setStuck(true);
            setVisible(true);
        }
        else {
            setStuck(false);
            setVisible(function (prevVisible) { return !prevVisible; });
        }
    }, [disabled, stuck]);
    return {
        active: active,
        stuck: stuck,
        visible: visible,
        setVisible: setVisible,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        enableHoverMode: enableHoverMode,
        disableHoverMode: disableHoverMode,
        startDisableTimer: startDisableTimer,
        clearHoverTimeout: clearHoverTimeout,
        handlers: {
            onClick: onClick,
            onMouseEnter: onMouseEnter,
            onMouseLeave: onMouseLeave,
        },
        hoverHandlers: {
            onMouseEnter: onMouseEnter,
            onMouseLeave: onMouseLeave,
        },
    };
}
//# sourceMappingURL=useHoverMode.js.map