import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord, } from "./getCoord";
/**
 * Attempts to position the fixed element so that it will appear to the left of
 * the container element but also within the viewport boundaries. When swapping
 * is enabled, it will attempt to swap to the right position if it can't fit
 * within the viewport to the left. If it can't fit in the viewport even after
 * being swapped to the right or swapping is disabled, it will be positioned to
 * the viewport left boundary.
 *
 * @internal
 */
export function createAnchoredLeft(config) {
    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
    var left = getLeftCoord(config);
    var actualX = "left";
    if (left >= vwMargin) {
        return { actualX: actualX, left: left };
    }
    var swappedLeft = getRightCoord(config);
    if (disableSwapping || swappedLeft + elWidth > screenRight) {
        left = vwMargin;
    }
    else {
        left = swappedLeft;
        actualX = "right";
    }
    return { actualX: actualX, left: left };
}
/**
 * Attempts to position the fixed element so that it will appear to the
 * inner-left of the container element but also within the viewport boundaries.
 * When swapping is enabled, it will attempt to swap to the right position if it
 * can't fit within the viewport to the left. If it can't fit in the viewport
 * even after being swapped to the right or swapping is disabled, it will be
 * positioned to the viewport left boundary.
 *
 * @internal
 */
export function createAnchoredInnerLeft(config) {
    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
    var left = getInnerLeftCoord(config);
    var actualX = "inner-left";
    if (left + elWidth <= screenRight && left >= vwMargin) {
        return { actualX: actualX, left: left };
    }
    if (disableSwapping) {
        if (left + elWidth > screenRight) {
            left = screenRight - elWidth;
        }
        else {
            left = vwMargin;
        }
        return { actualX: actualX, left: left };
    }
    var swappedLeft = getInnerRightCoord(config);
    if (swappedLeft < vwMargin) {
        left = vwMargin;
    }
    else if (swappedLeft + elWidth > screenRight) {
        left = screenRight - elWidth;
        actualX = "inner-right";
    }
    else {
        left = swappedLeft;
        actualX = "inner-right";
    }
    return { actualX: actualX, left: left };
}
/**
 * Attempts to position the fixed element so that it will appear at the center
 * of the container element but also within the viewport boundaries. If the
 * centered element can't fit within the viewport, it will use the vwMargin
 * value if it overflowed to the left, it'll position to the screen right
 * boundary.
 *
 * @internal
 */
export function createAnchoredCenter(config) {
    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth;
    var left = getCenterXCoord(config);
    if (left < vwMargin) {
        left = vwMargin;
    }
    else if (left + elWidth > screenRight || left < vwMargin) {
        left = screenRight - elWidth;
    }
    return { actualX: "center", left: left };
}
/**
 * Attempts to position the fixed element so that it will appear to the
 * inner-right of the container element but also within the viewport boundaries.
 * When swapping is enabled, it will attempt to swap to the inner-left position
 * if it can't fit within the viewport to the right. If it can't fit in the
 * viewport even after being swapped to the left or swapping is disabled, it
 * will be positioned to the viewport right boundary.
 *
 * @internal
 */
export function createAnchoredInnerRight(config) {
    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
    var left = getInnerRightCoord(config);
    var actualX = "inner-right";
    if (left >= vwMargin) {
        return { actualX: actualX, left: Math.min(left, screenRight - elWidth) };
    }
    var swappedLeft = getInnerLeftCoord(config);
    if (disableSwapping || swappedLeft + elWidth > screenRight) {
        left = vwMargin;
    }
    else {
        left = Math.max(swappedLeft, vwMargin);
        actualX = "inner-left";
    }
    return { actualX: actualX, left: left };
}
/**
 * Attempts to position the fixed element so that it will appear to the right of
 * the container element but also within the viewport boundaries. When swapping
 * is enabled, it will attempt to swap to the left position if it can't fit
 * within the viewport to the right. If it can't fit in the viewport even after
 * being swapped to the left or swapping is disabled, it will be positioned to
 * the viewport right boundary.
 *
 * @internal
 */
export function createAnchoredRight(config) {
    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;
    var left = getRightCoord(config);
    var actualX = "right";
    if (left + elWidth <= screenRight) {
        return { actualX: actualX, left: left };
    }
    var swappedLeft = getLeftCoord(config);
    if (disableSwapping || swappedLeft < vwMargin) {
        left = screenRight - elWidth;
    }
    else {
        left = swappedLeft;
        actualX = "left";
    }
    return { actualX: actualX, left: left };
}
/**
 * @internal
 */
export function createEqualWidth(options) {
    var x = options.x, elWidth = options.elWidth, xMargin = options.xMargin, vwMargin = options.vwMargin, initialX = options.initialX, containerRect = options.containerRect, screenRight = options.screenRight, isMinWidth = options.isMinWidth;
    var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;
    var width = containerRect.width - xMargin * 2;
    var minWidth;
    var right;
    if (isMinWidth) {
        minWidth = width;
        // if the fixed element has a width greater than the element it is fixed to,
        // update the width to be the fixed element's width. since the "min-width"
        // option is only possible for horizontally centered elements, need to then
        // update the `left` position again.
        if (elWidth > width) {
            left -= (elWidth - width) / 2;
            minWidth = elWidth;
        }
        width = undefined;
        var elRight = left + elWidth;
        if (elRight > screenRight) {
            left -= elRight - screenRight;
            right = vwMargin;
        }
        left = Math.max(vwMargin, left);
    }
    // going to assume that the container element is visible in the DOM and just
    // make the fixed element have the same left and right corners
    return {
        left: left,
        right: right,
        width: width,
        minWidth: minWidth,
        actualX: x,
    };
}
/**
 * Creates the horizontal position for a fixed element with the provided
 * options.
 * @internal
 */
export function createHorizontalPosition(options) {
    var x = options.x, vw = options.vw, vwMargin = options.vwMargin, xMargin = options.xMargin, width = options.width, elWidth = options.elWidth, initialX = options.initialX, containerRect = options.containerRect, disableSwapping = options.disableSwapping;
    var screenRight = vw - vwMargin;
    if (width === "min" || width === "equal") {
        return createEqualWidth({
            x: x,
            vwMargin: vwMargin,
            xMargin: xMargin,
            elWidth: elWidth,
            initialX: initialX,
            containerRect: containerRect,
            screenRight: screenRight,
            isMinWidth: width === "min",
        });
    }
    if (elWidth > vw - vwMargin * 2) {
        // if the element's width is greater than the viewport's width minus the
        // margin on both sides, just make the element span the entire viewport with
        // the margin
        return {
            left: vwMargin,
            right: vwMargin,
            actualX: x,
        };
    }
    var config = {
        vwMargin: vwMargin,
        xMargin: xMargin,
        elWidth: elWidth,
        initialX: initialX,
        screenRight: screenRight,
        containerRect: containerRect,
        disableSwapping: disableSwapping,
    };
    switch (x) {
        case "left":
            return createAnchoredLeft(config);
        case "inner-left":
            return createAnchoredInnerLeft(config);
        case "center":
            return createAnchoredCenter(config);
        case "inner-right":
            return createAnchoredInnerRight(config);
        case "right":
            return createAnchoredRight(config);
    }
}
//# sourceMappingURL=createHorizontalPosition.js.map