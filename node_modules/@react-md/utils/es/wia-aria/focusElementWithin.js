var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import { scrollIntoView } from "../scrollIntoView";
import { getFocusableElements } from "./getFocusableElements";
import { isFocusable } from "./isFocusable";
/**
 * A function that is used to focus an element within the provided node.  This
 * can either focus the first, last, or a querySelector found element.
 *
 * @param container - Either an HTMLElement or the document to focus an element
 * within.
 * @param focus - Either the "first" or "last" string to focus the first or last
 * focusable element within the container or a query selector string to find a
 * focusable element within the container.
 * @param programmatic - Boolean if programmatically focusable elements should be
 * included as well.
 * @param preventScroll - Boolean if the focus event should not scroll the
 * element into view. This should normally remain `false`, but can be useful if
 * the element gets focused while offscreen during a transition.
 * @param elements - Optional child elements to search
 * @remarks \@since 2.8.0 Supports focusing the container element if it is
 * focusable
 */
export function focusElementWithin(container, focus, programmatic, preventScroll, elements) {
    var _a;
    if (programmatic === void 0) { programmatic = false; }
    if (preventScroll === void 0) { preventScroll = false; }
    if (!elements || !elements.length) {
        elements = getFocusableElements(container, programmatic);
    }
    var el;
    switch (focus) {
        case "first":
            _a = __read(elements, 1), el = _a[0];
            break;
        case "last":
            el = elements[elements.length - 1];
            break;
        default:
            el = container.querySelector(focus);
    }
    // just allow any focusable-type element
    if (!el && isFocusable(container, "programmatic")) {
        el = container;
    }
    if (!el) {
        throw new Error("Unable to find a focusable element");
    }
    el.focus({ preventScroll: preventScroll });
    if (!preventScroll && container !== document) {
        scrollIntoView(container, el);
    }
}
//# sourceMappingURL=focusElementWithin.js.map