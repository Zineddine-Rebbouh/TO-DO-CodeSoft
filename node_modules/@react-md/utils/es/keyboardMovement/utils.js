import { loop } from "../loop";
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export var focusElement = function (element) {
    element.focus();
};
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export var isNotFocusable = function (element, includeDisabled) {
    if (!element) {
        return true;
    }
    if (includeDisabled) {
        return false;
    }
    return (element.getAttribute("disabled") !== null ||
        element.getAttribute("aria-disabled") === "true");
};
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export var getFirstFocusableIndex = function (watching, includeDisabled) {
    if (!watching.length) {
        return -1;
    }
    var firstIndex = 0;
    while (firstIndex < watching.length - 1 &&
        isNotFocusable(watching[firstIndex].element, includeDisabled)) {
        firstIndex += 1;
    }
    if (isNotFocusable(watching[firstIndex].element, includeDisabled)) {
        return -1;
    }
    return firstIndex;
};
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export var getLastFocusableIndex = function (watching, includeDisabled) {
    if (!watching.length) {
        return -1;
    }
    var lastIndex = watching.length - 1;
    while (lastIndex > 0 &&
        isNotFocusable(watching[lastIndex].element, includeDisabled)) {
        lastIndex -= 1;
    }
    if (isNotFocusable(watching[lastIndex].element, includeDisabled)) {
        return -1;
    }
    return lastIndex;
};
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export var getNextFocusableIndex = function (_a) {
    var loopable = _a.loopable, watching = _a.watching, increment = _a.increment, includeDisabled = _a.includeDisabled, currentFocusIndex = _a.currentFocusIndex;
    var min = getFirstFocusableIndex(watching, includeDisabled);
    var max = getLastFocusableIndex(watching, includeDisabled);
    var nextIndex = loop({
        min: min,
        max: max,
        value: currentFocusIndex,
        minmax: !loopable,
        increment: increment,
    });
    while (isNotFocusable(watching[nextIndex].element, includeDisabled) &&
        (loopable || nextIndex !== (increment ? max : min))) {
        nextIndex = loop({
            min: min,
            max: max,
            value: nextIndex,
            minmax: !loopable,
            increment: increment,
        });
    }
    // Since the `min` and `max` values are "safely" set, I don't need to verify
    // the nextIndex is still focusable
    return nextIndex;
};
/**
 * @remarks \@since 5.0.0
 * @internal
 */
export function getSearchText(element, searchable) {
    if (!searchable) {
        return "";
    }
    var cloned = element.cloneNode(true);
    cloned
        .querySelectorAll(".rmd-icon--font,[aria-hidden=true],[hidden]")
        .forEach(function (element) {
        var _a;
        (_a = element.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(element);
    });
    // Note: It would be good to use `cloned.innerText` (maybe?) at some point,
    // but it returns `undefined` in jsdom. It also does cause a reflow, so maybe
    // this is fine?
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent#differences_from_innertext
    return (cloned.textContent || "").substring(0, 1).toUpperCase();
}
//# sourceMappingURL=utils.js.map